{"schemas":[{"name":"MetaData","description":"\nThe Meta Data Layer contains information about CPG creation. In particular,\nit indicates which language frontend generated the CPG and which overlays\nhave been applied. The layer consists of a single node - the Meta Data node -\nand language frontends MUST create this node. Overlay creators MUST edit\nthis node to indicate that a layer has been successfully applied in all\ncases where applying the layer more than once is prohibitive.\n","providedByFrontend":true},{"name":"FileSystem","description":"\nCPGs are created from sets of files and the File System Layer describes the layout of\nthese files, that is, it provides information about source files\nand shared objects for source-based and machine-code-based frontends\nrespectively. The purpose of including this information in the CPG\nis to allow nodes of the graph to be mapped back to file system locations.\n","providedByFrontend":false},{"name":"Namespace","description":"\nMany programming languages allow code to be structured into namespaces. The Namespace\nLayer makes these namespaces explicit and associates program constructs with the\nnamespaces they are defined in.\n","providedByFrontend":false},{"name":"Method","description":"\nThe Method Layer contains declarations of methods, functions, and procedures.\nInput parameters and output parameters (including return parameters) are\nrepresented, however, method contents is not present in this layer.\n","providedByFrontend":true},{"name":"Type","description":"\nThe Type Layer contains information about type declarations, relations between\ntypes, and type instantiation and usage. In its current form, it allows moedling of\nparametrized types, type hierarchies and aliases.\n","providedByFrontend":true},{"name":"Ast","description":"\nThe Abstract Syntax Tree (AST) Layer provides syntax trees for all compilation units.\nAll nodes of the tree inherit from the same base class (`AST_NODE`) and are connected\nto their child nodes via outgoing `AST` edges.\n\nSyntax trees are typed, that is, when possible, types for all expressions are stored\nin the tree. Moreover, common control structure types are defined in the specification,\nmaking it possible to translate trees into corresponding control flow graphs if only\nthese common control structure types are used, possibly by desugaring on the side of\nthe language frontend. For cases where this is not an option,\nthe AST specification provides means of storing language-dependent information in the\nAST that can be interpreted by language-dependent control flow construction passes.\n\nThis layer MUST be created by the frontend.\n\n","providedByFrontend":true},{"name":"CallGraph","description":"\nThe Call Graph Layer represents call relations between methods.\n","providedByFrontend":false},{"name":"Cfg","description":"\nThe Control Flow Graph Layer provides control flow graphs for each method. Control\nflow graphs are constructed by marking a sub set of the abstract syntax tree nodes\nas control flow nodes (`CFG_NODE`) and connecting these nodes via `CFG` edges.\nThe control flow graph models both the control flow within the calculation of an\nexpression as well as from expression to expression. The layer can be automatically\ngenerated from the syntax tree layer if only control structure types supported by\nthis specification are employed.\n","providedByFrontend":false},{"name":"Dominators","description":"\nThe Dominators Layer provides dominator- and post-dominator trees for all methods.\nIt is constructed automatically from the control flow graph layer and is in turn\nused to automatically construct control dependence relations of the PDG layer.\n","providedByFrontend":false},{"name":"Pdg","description":"\n      The Program Dependence Graph Layer contains a program dependence graph for\neach method of the source program. A program dependence graph consists\nof a data dependence graph (DDG) and a control dependence graph (CDG),\ncreated by connecting nodes of the control flow graph via `REACHING_DEF`\nand `CDG` edges respectively.\n","providedByFrontend":false},{"name":"Comment","description":"\n","providedByFrontend":true},{"name":"Finding","description":"\nWe allow findings (e.g., potential vulnerabilities, notes on dangerous practices) to\nbe stored in the Findings Layer.\n","providedByFrontend":false},{"name":"Shortcuts","description":"\nThe Shortcuts Layer provides shortcut edges calculated to speed up\nsubsequent queries. Language frontends MUST NOT create shortcut edges.\n","providedByFrontend":false},{"name":"TagsAndLocation","description":"\nThe Code Property Graph specification allows for tags to be attached\nto arbitrary nodes. Conceptually, this is similar to the creation of\nFinding nodes, however, tags are to be used for intermediate results\nrather than end-results that are to be reported to the user.\n","providedByFrontend":false},{"name":"Base","description":"\n","providedByFrontend":true}],"nodes":[{"name":"META_DATA","comment":"This node contains the CPG meta data. Exactly one node of this type\nMUST exist per CPG. The `HASH` property MAY contain a hash value calculated\nover the source files this CPG was generated from. The `VERSION` MUST be\nset to the version of the specification (\"1.1\"). The language field indicates\nwhich language frontend was used to generate the CPG and the list property\n`OVERLAYS` specifies which overlays have been applied to the CPG.","extends":[],"allProperties":["HASH","LANGUAGE","OVERLAYS","VERSION"],"cardinalities":["zeroOrOne","one","list","one"],"inheritedProperties":[],"properties":["HASH","LANGUAGE","OVERLAYS","VERSION"],"schema":"MetaData","schemaIndex":2,"isAbstract":false,"containedNodes":[]},{"name":"FILE","comment":"File nodes represent source files or a shared objects from which the CPG\nwas generated. File nodes serve as indices, that is, they allow looking up all\nelements of the code by file.\n\nFor each file, the graph MUST contain exactly one File node.\nAs file nodes are root nodes of abstract syntax tress, they are AstNodes and\ntheir order field is set to 0. This is because they have no sibling nodes,\nnot because they are the first node of the AST.\n\nEach CPG MUST contain a special file node with name set to\n`<unknown>`. This node is a placeholder used in cases where a file cannot be\ndetermined at compile time. As an example, consider external library functions.\nAs their code is not available on CPG construction, the file name is unknown.\n\nFile nodes MUST NOT be created by the language frontend. Instead, the language\nfrontend is assumed to fill out the `FILENAME` field wherever possible,\nallowing File nodes to be created automatically upon first loading the CPG.","extends":["AST_NODE"],"allProperties":["CODE","COLUMN_NUMBER","HASH","LINE_NUMBER","NAME","ORDER"],"cardinalities":["one","zeroOrOne","zeroOrOne","zeroOrOne","one","one"],"inheritedProperties":[{"baseType":"AST_NODE","name":"CODE"},{"baseType":"AST_NODE","name":"COLUMN_NUMBER"},{"baseType":"AST_NODE","name":"LINE_NUMBER"},{"baseType":"AST_NODE","name":"ORDER"}],"properties":["HASH","NAME"],"schema":"FileSystem","schemaIndex":3,"isAbstract":false,"containedNodes":[]},{"name":"NAMESPACE","comment":"This node represents a namespace. Similar to FILE nodes, NAMESPACE nodes\nserve as indices that allow all definitions inside a namespace to be\nobtained by following outgoing edges from a NAMESPACE node.\n                    |\nNAMESPACE nodes MUST NOT be created by language frontends. Instead,\nthey are generated from NAMESPACE_BLOCK nodes automatically upon\nfirst loading of the CPG.","extends":["AST_NODE"],"allProperties":["CODE","COLUMN_NUMBER","LINE_NUMBER","NAME","ORDER"],"cardinalities":["one","zeroOrOne","zeroOrOne","one","one"],"inheritedProperties":[{"baseType":"AST_NODE","name":"CODE"},{"baseType":"AST_NODE","name":"COLUMN_NUMBER"},{"baseType":"AST_NODE","name":"LINE_NUMBER"},{"baseType":"AST_NODE","name":"ORDER"}],"properties":["NAME"],"schema":"Namespace","schemaIndex":4,"isAbstract":false,"containedNodes":[]},{"name":"NAMESPACE_BLOCK","comment":"A reference to a namespace.\nWe borrow the concept of a \"namespace block\" from C++, that is, a namespace block\nis a block of code that has been placed in the same namespace by a programmer.\nThis block may be introduced via a `package` statement in Java or\na `namespace{ }` statement in C++.\n\nThe `FULL_NAME` field contains the namespace name in a human-readable format.\nThe name should be given in dot-separated form where a dot indicates\nthe the right hand side is a sub namespace of the left hand side, e.g.,\n`foo.bar` denotes the namespace `bar` contained in the namespace `foo`.\n\nThe `NAME` field contains the name of the namespace without the names of\nits parent namespaces, e.g., for the namespace `foo.woo.bar`, the `NAME`\nfield is `bar`.","extends":["AST_NODE"],"allProperties":["CODE","COLUMN_NUMBER","FILENAME","FULL_NAME","LINE_NUMBER","NAME","ORDER"],"cardinalities":["one","zeroOrOne","one","one","zeroOrOne","one","one"],"inheritedProperties":[{"baseType":"AST_NODE","name":"CODE"},{"baseType":"AST_NODE","name":"COLUMN_NUMBER"},{"baseType":"AST_NODE","name":"LINE_NUMBER"},{"baseType":"AST_NODE","name":"ORDER"}],"properties":["FILENAME","FULL_NAME","NAME"],"schema":"Namespace","schemaIndex":4,"isAbstract":false,"containedNodes":[]},{"name":"METHOD","comment":"Programming languages offer many closely-related concepts for describing blocks\nof code that can be executed with input parameters and return output parameters,\npossibly causing side effects. In the CPG specification, we refer to all of these\nconcepts (procedures, functions, methods, etc.) as methods. A single METHOD node\nmust exist for each method found in the source program.\n\nThe `FULL_NAME` field specifies the method's fully-qualified name, including\ninformation about the namespace it is contained in if applicable, the name field\nis the function's short name. The field `IS_EXTERNAL` indicates whether it was\npossible to identify a method body for the method. This is true for methods that\nare defined in the source program, and false for methods that are dynamically\nlinked to the program, that is, methods that exist in an external dependency.\n\nLine and column number information is specified in the optional fields\n`LINE_NUMBER`, `COLUMN_NUMBER`, `LINE_NUMBER_END`, and `COLUMN_NUMBER_END` and\nthe name of the source file is specified in `FILENAME`. An optional hash value\nMAY be calculated over the function contents and included in the `HASH` field.\n\nFinally, the fully qualified name of the program constructs that the method\nis immediately contained in is stored in the `AST_PARENT_FULL_NAME` field\nand its type is indicated in the `AST_PARENT_TYPE` field to be one of\n`METHOD`, `TYPE_DECL` or `NAMESPACE_BLOCK`.","extends":["AST_NODE","CFG_NODE","DECLARATION"],"allProperties":["AST_PARENT_FULL_NAME","AST_PARENT_TYPE","CODE","COLUMN_NUMBER","COLUMN_NUMBER_END","FILENAME","FULL_NAME","HASH","IS_EXTERNAL","LINE_NUMBER","LINE_NUMBER_END","NAME","ORDER","SIGNATURE"],"cardinalities":["one","one","one","zeroOrOne","zeroOrOne","one","one","zeroOrOne","one","zeroOrOne","zeroOrOne","one","one","one"],"inheritedProperties":[{"baseType":"DECLARATION","name":"NAME"},{"baseType":"CFG_NODE","name":"COLUMN_NUMBER"},{"baseType":"CFG_NODE","name":"ORDER"},{"baseType":"CFG_NODE","name":"CODE"},{"baseType":"CFG_NODE","name":"LINE_NUMBER"}],"properties":["AST_PARENT_FULL_NAME","AST_PARENT_TYPE","COLUMN_NUMBER_END","FILENAME","FULL_NAME","HASH","IS_EXTERNAL","LINE_NUMBER_END","SIGNATURE"],"schema":"Method","schemaIndex":5,"isAbstract":false,"containedNodes":[]},{"name":"METHOD_PARAMETER_IN","comment":"This node represents a formal input parameter. The field `NAME` contains its\nname, while the field `TYPE_FULL_NAME` contains the fully qualified type name.","extends":["AST_NODE","CFG_NODE","DECLARATION"],"allProperties":["CODE","COLUMN_NUMBER","EVALUATION_STRATEGY","LINE_NUMBER","NAME","ORDER","TYPE_FULL_NAME"],"cardinalities":["one","zeroOrOne","one","zeroOrOne","one","one","one"],"inheritedProperties":[{"baseType":"DECLARATION","name":"NAME"},{"baseType":"CFG_NODE","name":"COLUMN_NUMBER"},{"baseType":"CFG_NODE","name":"ORDER"},{"baseType":"CFG_NODE","name":"CODE"},{"baseType":"CFG_NODE","name":"LINE_NUMBER"}],"properties":["EVALUATION_STRATEGY","TYPE_FULL_NAME"],"schema":"Method","schemaIndex":5,"isAbstract":false,"containedNodes":[]},{"name":"METHOD_PARAMETER_OUT","comment":"This node represents a formal output parameter. Corresponding output parameters\nfor input parameters MUST NOT be created by the frontend as they are automatically\ncreated upon first loading the CPG.","extends":["AST_NODE","CFG_NODE","DECLARATION"],"allProperties":["CODE","COLUMN_NUMBER","EVALUATION_STRATEGY","LINE_NUMBER","NAME","ORDER","TYPE_FULL_NAME"],"cardinalities":["one","zeroOrOne","one","zeroOrOne","one","one","one"],"inheritedProperties":[{"baseType":"DECLARATION","name":"NAME"},{"baseType":"CFG_NODE","name":"COLUMN_NUMBER"},{"baseType":"CFG_NODE","name":"ORDER"},{"baseType":"CFG_NODE","name":"CODE"},{"baseType":"CFG_NODE","name":"LINE_NUMBER"}],"properties":["EVALUATION_STRATEGY","TYPE_FULL_NAME"],"schema":"Method","schemaIndex":5,"isAbstract":false,"containedNodes":[]},{"name":"METHOD_RETURN","comment":"This node represents an (unnamed) formal method return parameter. It carries its\nfully qualified type name in `TYPE_FULL_NAME`. The `CODE` field MAY be set freely,\ne.g., to the constant `RET`, however, subsequent layer creators MUST NOT depend\non this value.","extends":["CFG_NODE"],"allProperties":["CODE","COLUMN_NUMBER","EVALUATION_STRATEGY","LINE_NUMBER","ORDER","TYPE_FULL_NAME"],"cardinalities":["one","zeroOrOne","one","zeroOrOne","one","one"],"inheritedProperties":[{"baseType":"CFG_NODE","name":"CODE"},{"baseType":"CFG_NODE","name":"COLUMN_NUMBER"},{"baseType":"CFG_NODE","name":"LINE_NUMBER"},{"baseType":"CFG_NODE","name":"ORDER"}],"properties":["EVALUATION_STRATEGY","TYPE_FULL_NAME"],"schema":"Method","schemaIndex":5,"isAbstract":false,"containedNodes":[]},{"name":"MEMBER","comment":"This node represents a type member of a class, struct or union, e.g., for the\n type declaration `class Foo{ int i ; }`, it represents the declaration of the\n variable `i`.","extends":["AST_NODE","DECLARATION"],"allProperties":["CODE","COLUMN_NUMBER","LINE_NUMBER","NAME","ORDER","TYPE_FULL_NAME"],"cardinalities":["one","zeroOrOne","zeroOrOne","one","one","one"],"inheritedProperties":[{"baseType":"DECLARATION","name":"NAME"},{"baseType":"AST_NODE","name":"COLUMN_NUMBER"},{"baseType":"AST_NODE","name":"ORDER"},{"baseType":"AST_NODE","name":"CODE"},{"baseType":"AST_NODE","name":"LINE_NUMBER"}],"properties":["TYPE_FULL_NAME"],"schema":"Type","schemaIndex":6,"isAbstract":false,"containedNodes":[]},{"name":"TYPE","comment":"This node represents a type instance, that is, a concrete instantiation\nof a type declaration.","extends":[],"allProperties":["FULL_NAME","NAME","TYPE_DECL_FULL_NAME"],"cardinalities":["one","one","one"],"inheritedProperties":[],"properties":["FULL_NAME","NAME","TYPE_DECL_FULL_NAME"],"schema":"Type","schemaIndex":6,"isAbstract":false,"containedNodes":[]},{"name":"TYPE_ARGUMENT","comment":"An (actual) type argument as used to instantiate a parametrized type, in the\nsame way an (actual) arguments provides concrete values for a parameter\nat method call sites. As it true for arguments, the method is not expected\nto  interpret the type argument. It MUST however store its code in the\n`CODE` field.","extends":["AST_NODE"],"allProperties":["CODE","COLUMN_NUMBER","LINE_NUMBER","ORDER"],"cardinalities":["one","zeroOrOne","zeroOrOne","one"],"inheritedProperties":[{"baseType":"AST_NODE","name":"CODE"},{"baseType":"AST_NODE","name":"COLUMN_NUMBER"},{"baseType":"AST_NODE","name":"LINE_NUMBER"},{"baseType":"AST_NODE","name":"ORDER"}],"properties":[],"schema":"Type","schemaIndex":6,"isAbstract":false,"containedNodes":[]},{"name":"TYPE_DECL","comment":"This node represents a type declaration as for example given by a class-, struct-,\nor union declaration. In contrast to a `TYPE` node, this node does not represent a\nconcrete instantiation of a type, e.g., for the parametrized type `List[T]`, it represents\n`List[T]`, but not `List[Integer]` where `Integer` is a concrete type.\n\nThe language frontend MUST create type declarations for all types declared in the\nsource program and MAY provide type declarations for types that are not declared\nbut referenced by the source program. If a declaration is present in the source\nprogram, the field `IS_EXTERNAL` is set to `false`. Otherwise, it is set to `true`.\n\nThe `FULL_NAME` field specifies the type's fully-qualified name, including\ninformation about the namespace it is contained in if applicable, the name field\nis the type's short name. Line and column number information is specified in the\noptional fields `LINE_NUMBER`, `COLUMN_NUMBER`, `LINE_NUMBER_END`, and\n`COLUMN_NUMBER_END` and the name of the source file is specified in `FILENAME`.\n\nBase types can be specified via the `INHERITS_FROM_TYPE_FULL_NAME` list, where\neach entry contains the fully-qualified name of a base type. If the type is\nknown to be an alias of another type (as for example introduced via the C\n`typedef` statement), the name of the alias is stored in `ALIAS_TYPE_FULL_NAME`.\n\nFinally, the fully qualified name of the program constructs that the type declaration\nis immediately contained in is stored in the `AST_PARENT_FULL_NAME` field\nand its type is indicated in the `AST_PARENT_TYPE` field to be one of\n`METHOD`, `TYPE_DECL` or `NAMESPACE_BLOCK`.","extends":["AST_NODE"],"allProperties":["ALIAS_TYPE_FULL_NAME","AST_PARENT_FULL_NAME","AST_PARENT_TYPE","CODE","COLUMN_NUMBER","FILENAME","FULL_NAME","INHERITS_FROM_TYPE_FULL_NAME","IS_EXTERNAL","LINE_NUMBER","NAME","ORDER"],"cardinalities":["zeroOrOne","one","one","one","zeroOrOne","one","one","list","one","zeroOrOne","one","one"],"inheritedProperties":[{"baseType":"AST_NODE","name":"CODE"},{"baseType":"AST_NODE","name":"COLUMN_NUMBER"},{"baseType":"AST_NODE","name":"LINE_NUMBER"},{"baseType":"AST_NODE","name":"ORDER"}],"properties":["ALIAS_TYPE_FULL_NAME","AST_PARENT_FULL_NAME","AST_PARENT_TYPE","FILENAME","FULL_NAME","INHERITS_FROM_TYPE_FULL_NAME","IS_EXTERNAL","NAME"],"schema":"Type","schemaIndex":6,"isAbstract":false,"containedNodes":[]},{"name":"TYPE_PARAMETER","comment":"This node represents a formal type parameter, that is, the type parameter\nas given in a type-parametrized method or type declaration. Examples for\nlanguages that support type parameters are Java (via Generics) and C++\n(via templates). Apart from the standard fields of AST nodes, the type\nparameter carries only a `NAME` field that holds the parameters name.","extends":["AST_NODE"],"allProperties":["CODE","COLUMN_NUMBER","LINE_NUMBER","NAME","ORDER"],"cardinalities":["one","zeroOrOne","zeroOrOne","one","one"],"inheritedProperties":[{"baseType":"AST_NODE","name":"CODE"},{"baseType":"AST_NODE","name":"COLUMN_NUMBER"},{"baseType":"AST_NODE","name":"LINE_NUMBER"},{"baseType":"AST_NODE","name":"ORDER"}],"properties":["NAME"],"schema":"Type","schemaIndex":6,"isAbstract":false,"containedNodes":[]},{"name":"AST_NODE","comment":"This is the base type for all nodes of the abstract syntax tree (AST). An AST\nnode has a `CODE` and an `ORDER` field. The `CODE` field contains the\ncode (verbatim) represented by the AST node. The `ORDER` field contains the\nnodes position among its siblings, encoded as an integer where the left most\nsibling has the position `0`.\n\nAST nodes contain optional `LINE_NUMBER` and `COLUMN_NUMBER` fields. For\nsource-based frontends, these fields contain the start line number and\nstart column number of the code represented by the node.\nFor machine-code-based and bytecode-based frontends, `LINE_NUMBER` contains\nthe address at which the code starts while `COLUMN_NUMBER` is undefined.","extends":[],"allProperties":["CODE","COLUMN_NUMBER","LINE_NUMBER","ORDER"],"cardinalities":["one","zeroOrOne","zeroOrOne","one"],"inheritedProperties":[],"properties":["CODE","COLUMN_NUMBER","LINE_NUMBER","ORDER"],"schema":"Ast","schemaIndex":7,"isAbstract":true,"containedNodes":[]},{"name":"BLOCK","comment":"This node represents a compound statement. Compound statements are used in many languages to allow\ngrouping a sequence of statements. For example, in C and Java, compound statements\nare statements enclosed by curly braces. Function/Method bodies are compound\nstatements. We do not use the term \"compound statement\" because \"statement\" would\nimply that the block does not yield a value upon evaluation, that is, that it is\nnot an expression. This is true in languages such as C and Java, but not for languages\nsuch as Scala where the value of the block is given by that of the last expression it\ncontains. In fact, the Scala grammar uses the term \"BlockExpr\" (short for\n\"block expression\") to describe what in the CPG we call \"Block\".","extends":["EXPRESSION"],"allProperties":["ARGUMENT_INDEX","ARGUMENT_NAME","CODE","COLUMN_NUMBER","LINE_NUMBER","ORDER","TYPE_FULL_NAME"],"cardinalities":["one","zeroOrOne","one","zeroOrOne","zeroOrOne","one","one"],"inheritedProperties":[{"baseType":"EXPRESSION","name":"COLUMN_NUMBER"},{"baseType":"EXPRESSION","name":"ARGUMENT_INDEX"},{"baseType":"EXPRESSION","name":"ARGUMENT_NAME"},{"baseType":"EXPRESSION","name":"ORDER"},{"baseType":"EXPRESSION","name":"CODE"},{"baseType":"EXPRESSION","name":"LINE_NUMBER"}],"properties":["TYPE_FULL_NAME"],"schema":"Ast","schemaIndex":7,"isAbstract":false,"containedNodes":[]},{"name":"CALL","comment":"A (function/method/procedure) call. The `METHOD_FULL_NAME` property is the name of the\ninvoked method (the callee) while the `TYPE_FULL_NAME` is its return type, and\ntherefore, the return type of the call when viewing it as an expression. For\nlanguages like Javascript, it is common that we may know the (short-) name\nof the invoked method, but we do not know at compile time which method\nwill actually be invoked, e.g., because it depends on a dynamic import.\nIn this case, we leave `METHOD_FULL_NAME` blank but at least fill out `NAME`,\nwhich contains the method's (short-) name and `SIGNATURE`, which contains\nany information we may have about the types of arguments and return value.","extends":["EXPRESSION","CALL_REPR"],"allProperties":["ARGUMENT_INDEX","ARGUMENT_NAME","CODE","COLUMN_NUMBER","DISPATCH_TYPE","LINE_NUMBER","METHOD_FULL_NAME","NAME","ORDER","SIGNATURE","TYPE_FULL_NAME"],"cardinalities":["one","zeroOrOne","one","zeroOrOne","one","zeroOrOne","one","one","one","one","one"],"inheritedProperties":[{"baseType":"CALL_REPR","name":"NAME"},{"baseType":"CALL_REPR","name":"SIGNATURE"},{"baseType":"CALL_REPR","name":"COLUMN_NUMBER"},{"baseType":"EXPRESSION","name":"ARGUMENT_INDEX"},{"baseType":"EXPRESSION","name":"ARGUMENT_NAME"},{"baseType":"CALL_REPR","name":"ORDER"},{"baseType":"CALL_REPR","name":"CODE"},{"baseType":"CALL_REPR","name":"LINE_NUMBER"}],"properties":["DISPATCH_TYPE","METHOD_FULL_NAME","TYPE_FULL_NAME"],"schema":"Ast","schemaIndex":7,"isAbstract":false,"containedNodes":[]},{"name":"CALL_REPR","comment":"This is the base class of `CALL` that language implementers may safely ignore.","extends":["CFG_NODE"],"allProperties":["CODE","COLUMN_NUMBER","LINE_NUMBER","NAME","ORDER","SIGNATURE"],"cardinalities":["one","zeroOrOne","zeroOrOne","one","one","one"],"inheritedProperties":[{"baseType":"CFG_NODE","name":"CODE"},{"baseType":"CFG_NODE","name":"COLUMN_NUMBER"},{"baseType":"CFG_NODE","name":"LINE_NUMBER"},{"baseType":"CFG_NODE","name":"ORDER"}],"properties":["NAME","SIGNATURE"],"schema":"Ast","schemaIndex":7,"isAbstract":true,"containedNodes":[]},{"name":"CONTROL_STRUCTURE","comment":"This node represents a control structure as introduced by control structure\nstatements as well as conditional and unconditional jumps. Its type is stored in the\n`CONTROL_STRUCTURE_TYPE` field to be one of several pre-defined types. These types\n are used in the construction of the control flow layer, making it possible to\n generate the control flow layer from the abstract syntax tree layer automatically.\n\nIn addition to the `CONTROL_STRUCTURE_TYPE` field, the `PARSER_TYPE_NAME` field\nMAY be used by frontends to store the name of the control structure as emitted by\nthe parser or disassembler, however, the value of this field is not relevant\nfor construction of the control flow layer.","extends":["EXPRESSION"],"allProperties":["ARGUMENT_INDEX","ARGUMENT_NAME","CODE","COLUMN_NUMBER","CONTROL_STRUCTURE_TYPE","LINE_NUMBER","ORDER","PARSER_TYPE_NAME"],"cardinalities":["one","zeroOrOne","one","zeroOrOne","one","zeroOrOne","one","one"],"inheritedProperties":[{"baseType":"EXPRESSION","name":"COLUMN_NUMBER"},{"baseType":"EXPRESSION","name":"ARGUMENT_INDEX"},{"baseType":"EXPRESSION","name":"ARGUMENT_NAME"},{"baseType":"EXPRESSION","name":"ORDER"},{"baseType":"EXPRESSION","name":"CODE"},{"baseType":"EXPRESSION","name":"LINE_NUMBER"}],"properties":["CONTROL_STRUCTURE_TYPE","PARSER_TYPE_NAME"],"schema":"Ast","schemaIndex":7,"isAbstract":false,"containedNodes":[]},{"name":"EXPRESSION","comment":"`EXPRESSION` is the base class for all nodes that represent code pieces\nthat can be evaluated.\n\n Expression may be arguments in method calls. For method calls that do\n not involved named parameters, the `ARGUMENT_INDEX` field indicates at\n which position in the argument list the expression occurs, e.g., an\n `ARGUMENT_INDEX` of 1 indicates that the expression is the first argument\n in a method call. For calls that employ named parameters, `ARGUMENT_INDEX`\n is set to -1 and the `ARGUMENT_NAME` fields holds the name of the parameter.","extends":["AST_NODE","CFG_NODE"],"allProperties":["ARGUMENT_INDEX","ARGUMENT_NAME","CODE","COLUMN_NUMBER","LINE_NUMBER","ORDER"],"cardinalities":["one","zeroOrOne","one","zeroOrOne","zeroOrOne","one"],"inheritedProperties":[{"baseType":"CFG_NODE","name":"CODE"},{"baseType":"CFG_NODE","name":"COLUMN_NUMBER"},{"baseType":"CFG_NODE","name":"LINE_NUMBER"},{"baseType":"CFG_NODE","name":"ORDER"}],"properties":["ARGUMENT_INDEX","ARGUMENT_NAME"],"schema":"Ast","schemaIndex":7,"isAbstract":true,"containedNodes":[]},{"name":"FIELD_IDENTIFIER","comment":"This node represents the field accessed in a field access, e.g., in\n`a.b`, it represents `b`. The field name as it occurs in the code is\nstored in the `CODE` field. This may mean that the `CODE` field holds\nan expression. The `CANONICAL_NAME` field MAY contain the same value is\nthe `CODE` field but SHOULD contain the normalized name that results\nfrom evaluating `CODE` as an expression if such an evaluation is\npossible for the language frontend. The objective is to store an identifier\nin `CANONICAL_NAME` that is the same for two nodes iff they refer to the\nsame field, regardless of whether they use the same expression to reference\nit.","extends":["EXPRESSION"],"allProperties":["ARGUMENT_INDEX","ARGUMENT_NAME","CANONICAL_NAME","CODE","COLUMN_NUMBER","LINE_NUMBER","ORDER"],"cardinalities":["one","zeroOrOne","one","one","zeroOrOne","zeroOrOne","one"],"inheritedProperties":[{"baseType":"EXPRESSION","name":"COLUMN_NUMBER"},{"baseType":"EXPRESSION","name":"ARGUMENT_INDEX"},{"baseType":"EXPRESSION","name":"ARGUMENT_NAME"},{"baseType":"EXPRESSION","name":"ORDER"},{"baseType":"EXPRESSION","name":"CODE"},{"baseType":"EXPRESSION","name":"LINE_NUMBER"}],"properties":["CANONICAL_NAME"],"schema":"Ast","schemaIndex":7,"isAbstract":false,"containedNodes":[]},{"name":"IDENTIFIER","comment":"This node represents an identifier as used when referring to a variable by name.\nIt holds the identifier's name in the `NAME` field and its fully-qualified type\nname in `TYPE_FULL_NAME`.","extends":["EXPRESSION"],"allProperties":["ARGUMENT_INDEX","ARGUMENT_NAME","CODE","COLUMN_NUMBER","LINE_NUMBER","NAME","ORDER","TYPE_FULL_NAME"],"cardinalities":["one","zeroOrOne","one","zeroOrOne","zeroOrOne","one","one","one"],"inheritedProperties":[{"baseType":"EXPRESSION","name":"COLUMN_NUMBER"},{"baseType":"EXPRESSION","name":"ARGUMENT_INDEX"},{"baseType":"EXPRESSION","name":"ARGUMENT_NAME"},{"baseType":"EXPRESSION","name":"ORDER"},{"baseType":"EXPRESSION","name":"CODE"},{"baseType":"EXPRESSION","name":"LINE_NUMBER"}],"properties":["NAME","TYPE_FULL_NAME"],"schema":"Ast","schemaIndex":7,"isAbstract":false,"containedNodes":[]},{"name":"JUMP_TARGET","comment":"A jump target is any location in the code that has been specifically marked\nas the target of a jump, e.g., via a label. The `NAME` field holds the name of\nthe label while the `PARSER_TYPE_NAME` field holds the name of language construct\nthat this jump target is created from, e.g., \"Label\".","extends":["AST_NODE","CFG_NODE"],"allProperties":["ARGUMENT_INDEX","CODE","COLUMN_NUMBER","LINE_NUMBER","NAME","ORDER","PARSER_TYPE_NAME"],"cardinalities":["one","one","zeroOrOne","zeroOrOne","one","one","one"],"inheritedProperties":[{"baseType":"CFG_NODE","name":"CODE"},{"baseType":"CFG_NODE","name":"COLUMN_NUMBER"},{"baseType":"CFG_NODE","name":"LINE_NUMBER"},{"baseType":"CFG_NODE","name":"ORDER"}],"properties":["ARGUMENT_INDEX","NAME","PARSER_TYPE_NAME"],"schema":"Ast","schemaIndex":7,"isAbstract":false,"containedNodes":[]},{"name":"LITERAL","comment":"This node represents a literal such as an integer or string constant. Literals\nare symbols included in the code in verbatim form and which are immutable.\nThe `TYPE_FULL_NAME` field stores the literal's fully-qualified type name,\ne.g., `java.lang.Integer`.","extends":["EXPRESSION"],"allProperties":["ARGUMENT_INDEX","ARGUMENT_NAME","CODE","COLUMN_NUMBER","LINE_NUMBER","ORDER","TYPE_FULL_NAME"],"cardinalities":["one","zeroOrOne","one","zeroOrOne","zeroOrOne","one","one"],"inheritedProperties":[{"baseType":"EXPRESSION","name":"COLUMN_NUMBER"},{"baseType":"EXPRESSION","name":"ARGUMENT_INDEX"},{"baseType":"EXPRESSION","name":"ARGUMENT_NAME"},{"baseType":"EXPRESSION","name":"ORDER"},{"baseType":"EXPRESSION","name":"CODE"},{"baseType":"EXPRESSION","name":"LINE_NUMBER"}],"properties":["TYPE_FULL_NAME"],"schema":"Ast","schemaIndex":7,"isAbstract":false,"containedNodes":[]},{"name":"LOCAL","comment":"This node represents a local variable. Its fully qualified type name is stored\nin the `TYPE_FULL_NAME` field and its name in the `NAME` field. The `CODE` field\ncontains the entire local variable declaration without initialization, e.g., for\n`int x = 10;`, it contains `int x`.","extends":["AST_NODE","DECLARATION"],"allProperties":["CODE","COLUMN_NUMBER","LINE_NUMBER","NAME","ORDER","TYPE_FULL_NAME"],"cardinalities":["one","zeroOrOne","zeroOrOne","one","one","one"],"inheritedProperties":[{"baseType":"DECLARATION","name":"NAME"},{"baseType":"AST_NODE","name":"COLUMN_NUMBER"},{"baseType":"AST_NODE","name":"ORDER"},{"baseType":"AST_NODE","name":"CODE"},{"baseType":"AST_NODE","name":"LINE_NUMBER"}],"properties":["TYPE_FULL_NAME"],"schema":"Ast","schemaIndex":7,"isAbstract":false,"containedNodes":[]},{"name":"METHOD_REF","comment":"This node represents a reference to a method/function/procedure as it\nappears when a method is passed as an argument in a call. The `METHOD_FULL_NAME`\nfield holds the fully-qualified name of the referenced method and the\n`TYPE_FULL_NAME` holds its fully-qualified type name.","extends":["EXPRESSION"],"allProperties":["ARGUMENT_INDEX","ARGUMENT_NAME","CODE","COLUMN_NUMBER","LINE_NUMBER","METHOD_FULL_NAME","ORDER","TYPE_FULL_NAME"],"cardinalities":["one","zeroOrOne","one","zeroOrOne","zeroOrOne","one","one","one"],"inheritedProperties":[{"baseType":"EXPRESSION","name":"COLUMN_NUMBER"},{"baseType":"EXPRESSION","name":"ARGUMENT_INDEX"},{"baseType":"EXPRESSION","name":"ARGUMENT_NAME"},{"baseType":"EXPRESSION","name":"ORDER"},{"baseType":"EXPRESSION","name":"CODE"},{"baseType":"EXPRESSION","name":"LINE_NUMBER"}],"properties":["METHOD_FULL_NAME","TYPE_FULL_NAME"],"schema":"Ast","schemaIndex":7,"isAbstract":false,"containedNodes":[]},{"name":"MODIFIER","comment":"This field represents a (language-dependent) modifier such as `static`, `private`\nor `public`. Unlike most other AST nodes, it is NOT an expression, that is, it\ncannot be evaluated and cannot be passed as an argument in function calls.","extends":["AST_NODE"],"allProperties":["CODE","COLUMN_NUMBER","LINE_NUMBER","MODIFIER_TYPE","ORDER"],"cardinalities":["one","zeroOrOne","zeroOrOne","one","one"],"inheritedProperties":[{"baseType":"AST_NODE","name":"CODE"},{"baseType":"AST_NODE","name":"COLUMN_NUMBER"},{"baseType":"AST_NODE","name":"LINE_NUMBER"},{"baseType":"AST_NODE","name":"ORDER"}],"properties":["MODIFIER_TYPE"],"schema":"Ast","schemaIndex":7,"isAbstract":false,"containedNodes":[]},{"name":"RETURN","comment":"This node represents a return instruction, e.g., `return x`. Note that it does\nNOT represent a formal return parameter as formal return parameters are\nrepresented via `METHOD_RETURN` nodes.","extends":["EXPRESSION"],"allProperties":["ARGUMENT_INDEX","ARGUMENT_NAME","CODE","COLUMN_NUMBER","LINE_NUMBER","ORDER"],"cardinalities":["one","zeroOrOne","one","zeroOrOne","zeroOrOne","one"],"inheritedProperties":[{"baseType":"EXPRESSION","name":"COLUMN_NUMBER"},{"baseType":"EXPRESSION","name":"ARGUMENT_INDEX"},{"baseType":"EXPRESSION","name":"ARGUMENT_NAME"},{"baseType":"EXPRESSION","name":"ORDER"},{"baseType":"EXPRESSION","name":"CODE"},{"baseType":"EXPRESSION","name":"LINE_NUMBER"}],"properties":[],"schema":"Ast","schemaIndex":7,"isAbstract":false,"containedNodes":[]},{"name":"TYPE_REF","comment":"Reference to a type/class","extends":["EXPRESSION"],"allProperties":["ARGUMENT_INDEX","ARGUMENT_NAME","CODE","COLUMN_NUMBER","LINE_NUMBER","ORDER","TYPE_FULL_NAME"],"cardinalities":["one","zeroOrOne","one","zeroOrOne","zeroOrOne","one","one"],"inheritedProperties":[{"baseType":"EXPRESSION","name":"COLUMN_NUMBER"},{"baseType":"EXPRESSION","name":"ARGUMENT_INDEX"},{"baseType":"EXPRESSION","name":"ARGUMENT_NAME"},{"baseType":"EXPRESSION","name":"ORDER"},{"baseType":"EXPRESSION","name":"CODE"},{"baseType":"EXPRESSION","name":"LINE_NUMBER"}],"properties":["TYPE_FULL_NAME"],"schema":"Ast","schemaIndex":7,"isAbstract":false,"containedNodes":[]},{"name":"UNKNOWN","comment":"Any AST node that the frontend would like to include in the AST but for\nwhich no suitable AST node is specified in the CPG specification may be\nincluded using a node of type `UNKNOWN`.","extends":["EXPRESSION"],"allProperties":["ARGUMENT_INDEX","ARGUMENT_NAME","CODE","COLUMN_NUMBER","CONTAINED_REF","LINE_NUMBER","ORDER","PARSER_TYPE_NAME","TYPE_FULL_NAME"],"cardinalities":["one","zeroOrOne","one","zeroOrOne","one","zeroOrOne","one","one","one"],"inheritedProperties":[{"baseType":"EXPRESSION","name":"COLUMN_NUMBER"},{"baseType":"EXPRESSION","name":"ARGUMENT_INDEX"},{"baseType":"EXPRESSION","name":"ARGUMENT_NAME"},{"baseType":"EXPRESSION","name":"ORDER"},{"baseType":"EXPRESSION","name":"CODE"},{"baseType":"EXPRESSION","name":"LINE_NUMBER"}],"properties":["CONTAINED_REF","PARSER_TYPE_NAME","TYPE_FULL_NAME"],"schema":"Ast","schemaIndex":7,"isAbstract":false,"containedNodes":[]},{"name":"CFG_NODE","comment":"This is the base class for all control flow nodes. It is itself\na child class of `AST_NODE`, that is, all control flow graph nodes\nare also syntax tree nodes in the CPG specification.\n\"","extends":["AST_NODE"],"allProperties":["CODE","COLUMN_NUMBER","LINE_NUMBER","ORDER"],"cardinalities":["one","zeroOrOne","zeroOrOne","one"],"inheritedProperties":[{"baseType":"AST_NODE","name":"CODE"},{"baseType":"AST_NODE","name":"COLUMN_NUMBER"},{"baseType":"AST_NODE","name":"LINE_NUMBER"},{"baseType":"AST_NODE","name":"ORDER"}],"properties":[],"schema":"Cfg","schemaIndex":9,"isAbstract":true,"containedNodes":[]},{"name":"COMMENT","comment":"A source code comment","extends":[],"allProperties":["CODE","FILENAME","LINE_NUMBER"],"cardinalities":["one","one","zeroOrOne"],"inheritedProperties":[],"properties":["CODE","FILENAME","LINE_NUMBER"],"schema":"Comment","schemaIndex":12,"isAbstract":false,"containedNodes":[]},{"name":"FINDING","comment":"Finding nodes may be used to store analysis results in the graph\nthat are to be exposed to an end-user, e.g., information about\npotential vulnerabilities or dangerous programming practices.\nA Finding node may contain an abitrary list of key value pairs\nthat characterize the finding, as well as a list of nodes that\nserve as evidence for the finding.","extends":[],"allProperties":[],"cardinalities":[],"inheritedProperties":[],"properties":[],"schema":"Finding","schemaIndex":15,"isAbstract":false,"containedNodes":[{"name":"evidence","type":"ABSTRACT_NODE","cardinality":"list"},{"name":"keyValuePairs","type":"KEY_VALUE_PAIR","cardinality":"list"}]},{"name":"KEY_VALUE_PAIR","comment":"This node represents a key value pair, where both the key and the value are strings.","extends":[],"allProperties":["KEY","VALUE"],"cardinalities":["one","one"],"inheritedProperties":[],"properties":["KEY","VALUE"],"schema":"Finding","schemaIndex":15,"isAbstract":false,"containedNodes":[]},{"name":"LOCATION","comment":"A location node summarizes a source code location.","extends":[],"allProperties":["CLASS_NAME","CLASS_SHORT_NAME","FILENAME","LINE_NUMBER","METHOD_FULL_NAME","METHOD_SHORT_NAME","NODE_LABEL","PACKAGE_NAME","SYMBOL"],"cardinalities":["one","one","one","zeroOrOne","one","one","one","one","one"],"inheritedProperties":[],"properties":["CLASS_NAME","CLASS_SHORT_NAME","FILENAME","LINE_NUMBER","METHOD_FULL_NAME","METHOD_SHORT_NAME","NODE_LABEL","PACKAGE_NAME","SYMBOL"],"schema":"TagsAndLocation","schemaIndex":17,"isAbstract":false,"containedNodes":[{"name":"node","type":"ABSTRACT_NODE","cardinality":"zeroOrOne"}]},{"name":"TAG","comment":"This node represents a tag.","extends":[],"allProperties":["NAME","VALUE"],"cardinalities":["one","one"],"inheritedProperties":[],"properties":["NAME","VALUE"],"schema":"TagsAndLocation","schemaIndex":17,"isAbstract":false,"containedNodes":[]},{"name":"TAG_NODE_PAIR","comment":"This node contains an arbitrary node and an associated tag node.","extends":[],"allProperties":[],"cardinalities":[],"inheritedProperties":[],"properties":[],"schema":"TagsAndLocation","schemaIndex":17,"isAbstract":false,"containedNodes":[{"name":"node","type":"ABSTRACT_NODE","cardinality":"one"},{"name":"tag","type":"TAG","cardinality":"one"}]},{"name":"DECLARATION","comment":"This is the base node class for all declarations.","extends":[],"allProperties":["NAME"],"cardinalities":["one"],"inheritedProperties":[],"properties":["NAME"],"schema":"Base","schemaIndex":2147483647,"isAbstract":true,"containedNodes":[]}],"edges":[{"name":"ALIAS_OF","comment":"This edge represents an alias relation between a type declaration and a type.\nThe language frontend MUST NOT create `ALIAS_OF` edges as they are created\nautomatically based on `ALIAS_TYPE_FULL_NAME` fields when the CPG is first loaded.","schema":"Type"},{"name":"ARGUMENT","comment":"Argument edges connect call sites (node type `CALL`) to their arguments\n(node type `EXPRESSION`) as well as `RETURN` nodes to the expressions\nthat return.","schema":"CallGraph"},{"name":"AST","comment":"This edge connects a parent node to its child in the syntax tree.","schema":"Ast"},{"name":"BINDS_TO","comment":"This edge connects type arguments to type parameters to indicate\nthat the type argument is used to instantiate the type parameter.","schema":"Type"},{"name":"CALL","comment":"This edge connects call sites, i.e., nodes with the type `CALL`, to the\nmethod node that represent the method they invoke. The frontend MAY create\n`CALL` edges but is not required to do so. Instead, of the `METHOD_FULL_NAME`\nfield of the `CALL` node is set correctly, `CALL` edges are created\nautomatically as the CPG is first loaded.","schema":"CallGraph"},{"name":"CDG","comment":"A CDG edge expresses that the destination node is control dependent on the source node.","schema":"Pdg"},{"name":"CFG","comment":"This edge indicates control flow from the source to the destination node.","schema":"Cfg"},{"name":"CONDITION","comment":"The edge connects control structure nodes to the expressions that holds their conditions.","schema":"Ast"},{"name":"CONTAINS","comment":"This edge connects a node to the method that contains it.","schema":"Shortcuts"},{"name":"DOMINATE","comment":"This edge indicates that the source node immediately dominates the destination node.","schema":"Dominators"},{"name":"EVAL_TYPE","comment":"This edge connects a node to its evaluation type.","schema":"Shortcuts"},{"name":"INHERITS_FROM","comment":"Inheritance relation between a type declaration and a type. This edge MUST NOT\n be created by the language frontend as it is automatically created from\n `INHERITS_FROM_TYPE_FULL_NAME` fields then the CPG is first loaded.","schema":"Type"},{"name":"PARAMETER_LINK","comment":"This edge connects a method input parameter to the corresponding\nmethod output parameter.","schema":"Shortcuts"},{"name":"POST_DOMINATE","comment":"This edge indicates that the source node immediately post dominates the destination node.","schema":"Dominators"},{"name":"REACHING_DEF","comment":"A reaching definition edge indicates that a variable produced at the source node reaches\nthe destination node without being reassigned on the way. The `VARIABLE` property indicates\nwhich variable is propagated.","schema":"Pdg"},{"name":"RECEIVER","comment":"Similar to `ARGUMENT` edges, `RECEIVER` edges connect call sites\nto their receiver arguments. A receiver argument is the object on\nwhich a method operates, that is, it is the expression that is\nassigned to the `this` pointer as control is transferred to the method.","schema":"CallGraph"},{"name":"REF","comment":"This edge indicates that the source node is an identifier that denotes\naccess to the destination node. For example, an identifier may reference\na local variable.","schema":"Base"},{"name":"SOURCE_FILE","comment":"This edge connects a node to the node that represents its source file. These\nedges MUST not be created by the language frontend but are automatically\ncreated based on `FILENAME` fields.","schema":"FileSystem"},{"name":"TAGGED_BY","comment":"Edges from nodes to the tags they are tagged by.","schema":"TagsAndLocation"}],"properties":[{"name":"ALIAS_TYPE_FULL_NAME","comment":"This property holds the fully qualified name of the type that the node is\na type alias of.","schema":"Type"},{"name":"ARGUMENT_INDEX","comment":"AST-children of CALL nodes have an argument index, that is used to match\ncall-site arguments with callee parameters. Explicit parameters are numbered\nfrom 1 to N, while index 0 is reserved for implicit self / this parameter.\nCALLs without implicit parameter therefore have arguments starting with index 1.\nAST-children of BLOCK nodes may have an argument index as well; in this case,\nthe last argument index determines the return expression of a BLOCK expression.\nIf the `PARAMETER_NAME` field is set, then the `ARGUMENT_INDEX` field is\nignored. It is suggested to set it to -1.","schema":"CallGraph"},{"name":"ARGUMENT_NAME","comment":"For calls involving named parameters, the `ARGUMENT_NAME` field holds the\nname of the parameter initialized by the expression. For all other calls,\nthis field is unset.","schema":"CallGraph"},{"name":"AST_PARENT_FULL_NAME","comment":"This field holds the FULL_NAME of the AST parent of an entity.","schema":"Base"},{"name":"AST_PARENT_TYPE","comment":"The type of the AST parent. Since this is only used in some parts of the graph,\nthe list does not include all possible parents by intention.\nPossible parents: METHOD, TYPE_DECL, NAMESPACE_BLOCK.","schema":"Base"},{"name":"CANONICAL_NAME","comment":"This field holds the canonical name of a `FIELD_IDENTIFIER`. It is typically\nidentical to the CODE field, but canonicalized according to source language\nsemantics. Human readable names are preferable. `FIELD_IDENTIFIER` nodes must\nshare identical `CANONICAL_NAME` if and\nonly if they alias, e.g., in C-style unions (if the aliasing relationship is\nunknown or there are partial overlaps, then one must make a reasonable guess,\nand trade off between false negatives and false positives).","schema":"Ast"},{"name":"CLASS_NAME","schema":"TagsAndLocation"},{"name":"CLASS_SHORT_NAME","schema":"TagsAndLocation"},{"name":"CODE","comment":"This field holds the code snippet that the node represents.","schema":"Base"},{"name":"COLUMN_NUMBER","comment":"This optional fields provides the column number of the program construct\nrepresented by the node.","schema":"FileSystem"},{"name":"COLUMN_NUMBER_END","comment":"This optional fields provides the column number at which the program construct\nrepresented by the node ends.","schema":"FileSystem"},{"name":"CONTAINED_REF","comment":"References to other nodes. This is not a real property; it exists here for the sake of proto serialization only. valueType and cardinality are meaningless.","schema":"ProtoSerialize"},{"name":"CONTROL_STRUCTURE_TYPE","comment":"The `CONTROL_STRUCTURE_TYPE` field indicates which kind of control structure\na `CONTROL_STRUCTURE` node represents. The available types are the following:\n BREAK, CONTINUE, DO, WHILE, FOR, GOTO, IF, ELSE, TRY, and SWITCH.","schema":"Ast"},{"name":"DISPATCH_TYPE","comment":"This field holds the dispatch type of a call, which is either `STATIC_DISPATCH` or\n`DYNAMIC_DISPATCH`. For statically dispatched method calls, the call target is known\nat compile time while for dynamically dispatched calls, it can only be determined at\nruntime as it may depend on the type of an object (as is the case for virtual method\ncalls) or calculation of an offset.","schema":"CallGraph"},{"name":"EVALUATION_STRATEGY","comment":"For formal method input parameters, output parameters, and return parameters,\nthis field holds the evaluation strategy, which is one of the following:\n1) `BY_REFERENCE` indicates that the parameter is passed by reference, 2)\n`BY_VALUE` indicates that it is passed by value, that is, a copy is made,\n3) `BY_SHARING` the parameter is a pointer/reference and it is shared with\nthe caller/callee. While a copy of the pointer is made, a copy of the object\nthat it points to is not made.","schema":"CallGraph"},{"name":"FILENAME","comment":"The absolute path of the source file this node was generated from. This field\nmust be set but may be set to the value `<unknown>` to indicate that no source\nfile can be associated with the node, e.g., because the node represents an\nentity known to exist because it is referenced, but for which the file that\nis is declared in is unknown.","schema":"FileSystem"},{"name":"FULL_NAME","comment":"This is the fully-qualified name of an entity, e.g., the fully-qualified\nname of a method or type. The details of what constitutes a fully-qualified\nname are language specific. This field SHOULD be human readable.","schema":"Base"},{"name":"HASH","comment":"This property contains a hash value in the form of a string.\nHashes can be used to summarize data, e.g., to summarize the\ncontents of source files or sub graphs. Such summaries are useful\nto determine whether code has already been analyzed in incremental\nanalysis pipelines. This property is optional to allow its calculation\nto be deferred or skipped if the hash is not needed.","schema":"Base"},{"name":"INHERITS_FROM_TYPE_FULL_NAME","comment":"The static types a TYPE_DECL inherits from. This property is matched against the\nFULL_NAME of TYPE nodes and thus it is required to have at least one TYPE node\nfor each TYPE_FULL_NAME","schema":"Type"},{"name":"IS_EXTERNAL","comment":"Indicates that the construct (METHOD or TYPE_DECL) is external, that is,\nit is referenced but not defined in the code (applies both to insular\nparsing and to library functions where we have header files only)","schema":"Base"},{"name":"KEY","comment":"This property denotes a key of a key-value pair.","schema":"Finding"},{"name":"LANGUAGE","comment":"This field indicates which CPG language frontend generated the CPG.\nFrontend developers may freely choose a value that describes their frontend\nso long as it is not used by an existing frontend. Reserved values are to date:\nC, LLVM, GHIDRA, PHP.","schema":"MetaData"},{"name":"LINE_NUMBER","comment":"This optional field provides the line number of the program construct\nrepresented by the node.","schema":"FileSystem"},{"name":"LINE_NUMBER_END","comment":"This optional fields provides the line number at which the program construct\nrepresented by the node ends.","schema":"FileSystem"},{"name":"METHOD_FULL_NAME","comment":"The FULL_NAME of a method. Used to link CALL and METHOD nodes. It is required\nto have exactly one METHOD node for each METHOD_FULL_NAME","schema":"CallGraph"},{"name":"METHOD_SHORT_NAME","schema":"TagsAndLocation"},{"name":"MODIFIER_TYPE","comment":"The modifier type is a free-form string. The following are known modifier types:\n`STATIC`, `PUBLIC`, `PROTECTED`, `PRIVATE`, `ABSTRACT`, `NATIVE`, `CONSTRUCTOR`, `VIRTUAL`.","schema":"Ast"},{"name":"NAME","comment":"Name of represented object, e.g., method name (e.g. \"run\")","schema":"Base"},{"name":"NODE_LABEL","schema":"TagsAndLocation"},{"name":"ORDER","comment":"This integer indicates the position of the node among\nits siblings in the AST. The left-most child has an\norder of 0.","schema":"Ast"},{"name":"OVERLAYS","comment":"The field contains the names of the overlays applied to this CPG, in order of their\napplication. Names are free-form strings, that is, this specification does not\ndictate them but rather requires tool producers and consumers to communicate them\nbetween each other.","schema":"MetaData"},{"name":"PACKAGE_NAME","schema":"TagsAndLocation"},{"name":"PARSER_TYPE_NAME","comment":"AST node type name emitted by parser.","schema":"Base"},{"name":"SIGNATURE","comment":"The method signature encodes the types of parameters in a string.\nThe string SHOULD be human readable and suitable for differentiating methods\nwith different parameter types sufficiently to allow for resolving of\nfunction overloading. The present specification does not enforce a strict\nformat for the signature, that is, it can be chosen by the frontend\nimplementor to fit the source language.","schema":"Method"},{"name":"SYMBOL","schema":"TagsAndLocation"},{"name":"TYPE_DECL_FULL_NAME","comment":"The static type decl of a TYPE. This property is matched against the FULL_NAME\nof TYPE_DECL nodes. It is required to have exactly one TYPE_DECL for each\ndifferent TYPE_DECL_FULL_NAME","schema":"Type"},{"name":"TYPE_FULL_NAME","comment":"This field contains the fully-qualified static type name of the program\nconstruct represented by a node. It is the name of an instantiated type, e.g.,\n`java.util.List<Integer>`, rather than `java.util.List[T]`. If the type\ncannot be determined, this field should be set to the empty string.","schema":"Type"},{"name":"VALUE","comment":"This property denotes a string value as used in a key-value pair.","schema":"Base"},{"name":"VARIABLE","comment":"This edge property represents the variable propagated by a reaching definition edge.","schema":"Pdg"},{"name":"VERSION","comment":"A version, given as a string. Used, for example, in the META_DATA node to\nindicate which version of the CPG spec this CPG conforms to","schema":"Base"}]}