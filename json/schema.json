{"schemas":[{"name":"MetaData","description":"\nThe Meta Data Layer contains information about CPG creation. In particular,\nit indicates which language frontend generated the CPG and which overlays\nhave been applied. The layer consists of a single node - the Meta Data node -\nand language frontends MUST create this node. Overlay creators MUST edit\nthis node to indicate that a layer has been successfully applied in all\ncases where applying the layer more than once is prohibitive.\n","providedByFrontend":true},{"name":"FileSystem","description":"\nCPGs are created from sets of files and the File System Layer describes the layout of\nthese files, that is, it provides information about source files\nand shared objects for source-based and machine-code-based frontends\nrespectively. The purpose of including this information in the CPG\nis to allow nodes of the graph to be mapped back to file system locations.\n","providedByFrontend":false},{"name":"Namespace","description":"\nMany programming languages allow code to be structured into namespaces. The Namespace\nLayer makes these namespaces explicit and associates program constructs with the\nnamespaces they are defined in.\n","providedByFrontend":false},{"name":"Method","description":"\nThe Method Layer contains declarations of methods, functions, and procedures.\n","providedByFrontend":true},{"name":"Type","description":"\n Type layer (local).\n","providedByFrontend":true},{"name":"Ast","description":"\nAbstract syntax tree layer.\n","providedByFrontend":true},{"name":"Cfg","description":"\n","providedByFrontend":false},{"name":"Pdg","description":"\n","providedByFrontend":false},{"name":"CallGraph","description":"\n","providedByFrontend":false},{"name":"Dominators","description":"\n","providedByFrontend":false},{"name":"Comment","description":"\n","providedByFrontend":true},{"name":"Closure","description":"\n\n","providedByFrontend":false},{"name":"Finding","description":"\n\n","providedByFrontend":false},{"name":"Shortcuts","description":"\nShortcut edges calculated by the backend.\nThese edges should NOT be created by the language frontend.\n","providedByFrontend":false},{"name":"TagsAndLocation","description":"\n\n","providedByFrontend":false},{"name":"Base","description":"\n","providedByFrontend":true}],"nodes":[{"name":"META_DATA","comment":"This node contains the CPG meta data. Exactly one node of this type\nMUST exist per CPG. The `HASH` property MAY contain a hash value calculated\nover the source files this CPG was generated from. The `VERSION` MUST be\nset to the version of the specification (\"1.1\"). The language field indicates\nwhich language frontend was used to generate the CPG and the list property\n`OVERLAYS` specifies which overlays have been applied to the CPG.","extends":[],"allProperties":["HASH","LANGUAGE","OVERLAYS","VERSION"],"cardinalities":["zeroOrOne","one","list","one"],"inheritedProperties":[],"properties":["HASH","LANGUAGE","OVERLAYS","VERSION"],"schema":"MetaData","schemaIndex":2,"isAbstract":false,"containedNodes":[]},{"name":"FILE","comment":"File nodes represent source files or a shared objects from which the CPG\nwas generated. File nodes serve as indices, that is, they allow looking up all\nelements of the code by file.\n\nFor each file, the graph MUST contain exactly one File node.\nAs file nodes are root nodes of abstract syntax tress, they are AstNodes and\ntheir order field is set to 0. This is because they have no sibling nodes,\nnot because they are the first node of the AST.\n\nEach CPG MUST contain a special file node with name set to\n`<unknown>`. This node is a placeholder used in cases where a file cannot be\ndetermined at compile time. As an example, consider external library functions.\nAs their code is not available on CPG construction, the file name is unknown.\n\nFile nodes MUST NOT be created by the language frontend. Instead, the language\nfrontend is assumed to fill out the `FILENAME` field wherever possible,\nallowing File nodes to be created automatically upon first loading the CPG.","extends":["AST_NODE"],"allProperties":["CODE","COLUMN_NUMBER","HASH","LINE_NUMBER","NAME","ORDER"],"cardinalities":["one","zeroOrOne","zeroOrOne","zeroOrOne","one","one"],"inheritedProperties":[{"baseType":"AST_NODE","name":"CODE"},{"baseType":"AST_NODE","name":"COLUMN_NUMBER"},{"baseType":"AST_NODE","name":"LINE_NUMBER"},{"baseType":"AST_NODE","name":"ORDER"}],"properties":["HASH","NAME"],"schema":"FileSystem","schemaIndex":3,"isAbstract":false,"containedNodes":[]},{"name":"NAMESPACE","comment":"This node represents a namespace. Similar to FILE nodes, NAMESPACE nodes\nserve as indices that allow all definitions inside a namespace to be\nobtained by following outgoing edges from a NAMESPACE node.\n                    |\nNAMESPACE nodes MUST NOT be created by language frontends. Instead,\nthey are generated from NAMESPACE_BLOCK nodes automatically upon\nfirst loading of the CPG.","extends":["AST_NODE"],"allProperties":["CODE","COLUMN_NUMBER","LINE_NUMBER","NAME","ORDER"],"cardinalities":["one","zeroOrOne","zeroOrOne","one","one"],"inheritedProperties":[{"baseType":"AST_NODE","name":"CODE"},{"baseType":"AST_NODE","name":"COLUMN_NUMBER"},{"baseType":"AST_NODE","name":"LINE_NUMBER"},{"baseType":"AST_NODE","name":"ORDER"}],"properties":["NAME"],"schema":"Namespace","schemaIndex":4,"isAbstract":false,"containedNodes":[]},{"name":"NAMESPACE_BLOCK","comment":"A reference to a namespace.\nWe borrow the concept of a \"namespace block\" from C++, that is, a namespace block\nis a block of code that has been placed in the same namespace by a programmer.\nThis block may be introduced via a `package` statement in Java or\na `namespace{ }` statement in C++.\n\nThe `FULL_NAME` field contains the namespace name in a human-readable format.\nThe name should be given in dot-separated form where a dot indicates\nthe the right hand side is a sub namespace of the left hand side, e.g.,\n`foo.bar` denotes the namespace `bar` contained in the namespace `foo`.\n\nThe `NAME` field contains the name of the namespace without the names of\nits parent namespaces, e.g., for the namespace `foo.woo.bar`, the `NAME`\nfield is `bar`.","extends":["AST_NODE"],"allProperties":["CODE","COLUMN_NUMBER","FILENAME","FULL_NAME","LINE_NUMBER","NAME","ORDER"],"cardinalities":["one","zeroOrOne","one","one","zeroOrOne","one","one"],"inheritedProperties":[{"baseType":"AST_NODE","name":"CODE"},{"baseType":"AST_NODE","name":"COLUMN_NUMBER"},{"baseType":"AST_NODE","name":"LINE_NUMBER"},{"baseType":"AST_NODE","name":"ORDER"}],"properties":["FILENAME","FULL_NAME","NAME"],"schema":"Namespace","schemaIndex":4,"isAbstract":false,"containedNodes":[]},{"name":"BINDING","comment":"A binding of a METHOD into a TYPE_DECL","extends":[],"allProperties":["IS_METHOD_NEVER_OVERRIDDEN","NAME","SIGNATURE"],"cardinalities":["zeroOrOne","one","one"],"inheritedProperties":[],"properties":["IS_METHOD_NEVER_OVERRIDDEN","NAME","SIGNATURE"],"schema":"Method","schemaIndex":5,"isAbstract":false,"containedNodes":[]},{"name":"LOCAL","comment":"A local variable","extends":["DECLARATION","LOCAL_LIKE","AST_NODE"],"allProperties":["CLOSURE_BINDING_ID","CODE","COLUMN_NUMBER","LINE_NUMBER","NAME","ORDER","TYPE_FULL_NAME"],"cardinalities":["zeroOrOne","one","zeroOrOne","zeroOrOne","one","one","one"],"inheritedProperties":[{"baseType":"LOCAL_LIKE","name":"NAME"},{"baseType":"AST_NODE","name":"COLUMN_NUMBER"},{"baseType":"AST_NODE","name":"ORDER"},{"baseType":"AST_NODE","name":"CODE"},{"baseType":"AST_NODE","name":"LINE_NUMBER"}],"properties":["CLOSURE_BINDING_ID","TYPE_FULL_NAME"],"schema":"Method","schemaIndex":5,"isAbstract":false,"containedNodes":[]},{"name":"METHOD","comment":"A method/function/procedure","extends":["DECLARATION","CFG_NODE","AST_NODE"],"allProperties":["AST_PARENT_FULL_NAME","AST_PARENT_TYPE","CODE","COLUMN_NUMBER","COLUMN_NUMBER_END","FILENAME","FULL_NAME","HASH","IS_EXTERNAL","LINE_NUMBER","LINE_NUMBER_END","NAME","ORDER","SIGNATURE"],"cardinalities":["one","one","one","zeroOrOne","zeroOrOne","one","one","zeroOrOne","one","zeroOrOne","zeroOrOne","one","one","one"],"inheritedProperties":[{"baseType":"DECLARATION","name":"NAME"},{"baseType":"AST_NODE","name":"COLUMN_NUMBER"},{"baseType":"AST_NODE","name":"ORDER"},{"baseType":"AST_NODE","name":"CODE"},{"baseType":"AST_NODE","name":"LINE_NUMBER"}],"properties":["AST_PARENT_FULL_NAME","AST_PARENT_TYPE","COLUMN_NUMBER_END","FILENAME","FULL_NAME","HASH","IS_EXTERNAL","LINE_NUMBER_END","SIGNATURE"],"schema":"Method","schemaIndex":5,"isAbstract":false,"containedNodes":[]},{"name":"METHOD_PARAMETER_IN","comment":"This node represents a formal parameter going towards the callee side","extends":["DECLARATION","LOCAL_LIKE","CFG_NODE","AST_NODE"],"allProperties":["CODE","COLUMN_NUMBER","EVALUATION_STRATEGY","LINE_NUMBER","NAME","ORDER","TYPE_FULL_NAME"],"cardinalities":["one","zeroOrOne","one","zeroOrOne","one","one","one"],"inheritedProperties":[{"baseType":"LOCAL_LIKE","name":"NAME"},{"baseType":"AST_NODE","name":"COLUMN_NUMBER"},{"baseType":"AST_NODE","name":"ORDER"},{"baseType":"AST_NODE","name":"CODE"},{"baseType":"AST_NODE","name":"LINE_NUMBER"}],"properties":["EVALUATION_STRATEGY","TYPE_FULL_NAME"],"schema":"Method","schemaIndex":5,"isAbstract":false,"containedNodes":[]},{"name":"METHOD_PARAMETER_OUT","comment":"This node represents a formal output parameter. It does not need to be created by the frontend.","extends":["DECLARATION","CFG_NODE","AST_NODE"],"allProperties":["CODE","COLUMN_NUMBER","EVALUATION_STRATEGY","LINE_NUMBER","NAME","ORDER","TYPE_FULL_NAME"],"cardinalities":["one","zeroOrOne","one","zeroOrOne","one","one","one"],"inheritedProperties":[{"baseType":"DECLARATION","name":"NAME"},{"baseType":"AST_NODE","name":"COLUMN_NUMBER"},{"baseType":"AST_NODE","name":"ORDER"},{"baseType":"AST_NODE","name":"CODE"},{"baseType":"AST_NODE","name":"LINE_NUMBER"}],"properties":["EVALUATION_STRATEGY","TYPE_FULL_NAME"],"schema":"Method","schemaIndex":5,"isAbstract":false,"containedNodes":[]},{"name":"METHOD_RETURN","comment":"A formal method return","extends":["CFG_NODE"],"allProperties":["CODE","COLUMN_NUMBER","EVALUATION_STRATEGY","LINE_NUMBER","ORDER","TYPE_FULL_NAME"],"cardinalities":["one","zeroOrOne","one","zeroOrOne","one","one"],"inheritedProperties":[{"baseType":"CFG_NODE","name":"CODE"},{"baseType":"CFG_NODE","name":"COLUMN_NUMBER"},{"baseType":"CFG_NODE","name":"LINE_NUMBER"},{"baseType":"CFG_NODE","name":"ORDER"}],"properties":["EVALUATION_STRATEGY","TYPE_FULL_NAME"],"schema":"Method","schemaIndex":5,"isAbstract":false,"containedNodes":[]},{"name":"MEMBER","comment":"Member of a class struct or union","extends":["DECLARATION","AST_NODE"],"allProperties":["CODE","COLUMN_NUMBER","LINE_NUMBER","NAME","ORDER","TYPE_FULL_NAME"],"cardinalities":["one","zeroOrOne","zeroOrOne","one","one","one"],"inheritedProperties":[{"baseType":"DECLARATION","name":"NAME"},{"baseType":"AST_NODE","name":"COLUMN_NUMBER"},{"baseType":"AST_NODE","name":"ORDER"},{"baseType":"AST_NODE","name":"CODE"},{"baseType":"AST_NODE","name":"LINE_NUMBER"}],"properties":["TYPE_FULL_NAME"],"schema":"Type","schemaIndex":6,"isAbstract":false,"containedNodes":[]},{"name":"TYPE","comment":"A type which always has to reference a type declaration and may have type\nargument children if the referred to type declaration is a template","extends":[],"allProperties":["FULL_NAME","NAME","TYPE_DECL_FULL_NAME"],"cardinalities":["one","one","one"],"inheritedProperties":[],"properties":["FULL_NAME","NAME","TYPE_DECL_FULL_NAME"],"schema":"Type","schemaIndex":6,"isAbstract":false,"containedNodes":[]},{"name":"TYPE_ARGUMENT","comment":"Argument for a TYPE_PARAMETER that belongs to a TYPE. It binds another\nTYPE to a TYPE_PARAMETER","extends":["AST_NODE"],"allProperties":["CODE","COLUMN_NUMBER","LINE_NUMBER","ORDER"],"cardinalities":["one","zeroOrOne","zeroOrOne","one"],"inheritedProperties":[{"baseType":"AST_NODE","name":"CODE"},{"baseType":"AST_NODE","name":"COLUMN_NUMBER"},{"baseType":"AST_NODE","name":"LINE_NUMBER"},{"baseType":"AST_NODE","name":"ORDER"}],"properties":[],"schema":"Type","schemaIndex":6,"isAbstract":false,"containedNodes":[]},{"name":"TYPE_DECL","comment":"A type declaration","extends":["AST_NODE"],"allProperties":["ALIAS_TYPE_FULL_NAME","AST_PARENT_FULL_NAME","AST_PARENT_TYPE","CODE","COLUMN_NUMBER","FILENAME","FULL_NAME","INHERITS_FROM_TYPE_FULL_NAME","IS_EXTERNAL","LINE_NUMBER","NAME","ORDER"],"cardinalities":["zeroOrOne","one","one","one","zeroOrOne","one","one","list","one","zeroOrOne","one","one"],"inheritedProperties":[{"baseType":"AST_NODE","name":"CODE"},{"baseType":"AST_NODE","name":"COLUMN_NUMBER"},{"baseType":"AST_NODE","name":"LINE_NUMBER"},{"baseType":"AST_NODE","name":"ORDER"}],"properties":["ALIAS_TYPE_FULL_NAME","AST_PARENT_FULL_NAME","AST_PARENT_TYPE","FILENAME","FULL_NAME","INHERITS_FROM_TYPE_FULL_NAME","IS_EXTERNAL","NAME"],"schema":"Type","schemaIndex":6,"isAbstract":false,"containedNodes":[]},{"name":"TYPE_PARAMETER","comment":"Type parameter of TYPE_DECL or METHOD","extends":["AST_NODE"],"allProperties":["CODE","COLUMN_NUMBER","LINE_NUMBER","NAME","ORDER"],"cardinalities":["one","zeroOrOne","zeroOrOne","one","one"],"inheritedProperties":[{"baseType":"AST_NODE","name":"CODE"},{"baseType":"AST_NODE","name":"COLUMN_NUMBER"},{"baseType":"AST_NODE","name":"LINE_NUMBER"},{"baseType":"AST_NODE","name":"ORDER"}],"properties":["NAME"],"schema":"Type","schemaIndex":6,"isAbstract":false,"containedNodes":[]},{"name":"AST_NODE","comment":"Base type for all nodes are (in particular) nodes of the abstract syntax tree.\nIn a syntax tree, sibling nodes (nodes who share a parent node) are ordered.\nAs some graph databases do not guarantee the order in which siblings are returned to\nbe stable, we make the ordering explicit by storing the position of each node relative\nto its siblings in the order field. In the left most sibling, order is set to 0,\nwhile in the right-most sibling, it is set to n-1 where n is the number of siblings.","extends":[],"allProperties":["CODE","COLUMN_NUMBER","LINE_NUMBER","ORDER"],"cardinalities":["one","zeroOrOne","zeroOrOne","one"],"inheritedProperties":[],"properties":["CODE","COLUMN_NUMBER","LINE_NUMBER","ORDER"],"schema":"Ast","schemaIndex":7,"isAbstract":true,"containedNodes":[]},{"name":"BLOCK","comment":"A compound statement. Compound statements are used in many languages to allow\ngrouping a sequence of statements. For example, in C and Java, compound statements\nare statements enclosed by curly braces. Function/Method bodies are compound\nstatements. We do not use the term \"compound statement\" because \"statement\" would\nimply that the block does not yield a value upon evaluation, that is, that it is\nnot an expression. This is true in languages such as C and Java, but not for languages\nsuch as Scala where the value of the block is given by that of the last expression it\ncontains. In fact, the Scala grammar uses the term \\\"BlockExpr\\\" (short for\n\\\"block expression\\\") to describe what in the CPG spec we just call \\\"Block\\\".","extends":["EXPRESSION"],"allProperties":["ARGUMENT_INDEX","CODE","COLUMN_NUMBER","LINE_NUMBER","ORDER","TYPE_FULL_NAME"],"cardinalities":["one","one","zeroOrOne","zeroOrOne","one","one"],"inheritedProperties":[{"baseType":"EXPRESSION","name":"COLUMN_NUMBER"},{"baseType":"EXPRESSION","name":"ARGUMENT_INDEX"},{"baseType":"EXPRESSION","name":"ORDER"},{"baseType":"EXPRESSION","name":"CODE"},{"baseType":"EXPRESSION","name":"LINE_NUMBER"}],"properties":["TYPE_FULL_NAME"],"schema":"Ast","schemaIndex":7,"isAbstract":false,"containedNodes":[]},{"name":"CALL","comment":"A (function/method) call. The `methodFullName` property is the name of the\ninvoked method (the callee) while the `typeFullName` is its return type, and\ntherefore, the return type of the call when viewing it as an expression. For\nlanguages like Javascript, it is common that we may know the (short-) name\nof the invoked method, but we do not know at compile time which method\nwill actually be invoked, e.g., because it depends on a dynamic import.\nIn this case, we leave `methodFullName` blank but at least fill out `name`,\nwhich contains the method's (short-) name and `signature`, which contains\nany information we may have about the types of arguments and return value.","extends":["EXPRESSION","CALL_REPR"],"allProperties":["ARGUMENT_INDEX","CODE","COLUMN_NUMBER","DISPATCH_TYPE","LINE_NUMBER","METHOD_FULL_NAME","NAME","ORDER","SIGNATURE","TYPE_FULL_NAME"],"cardinalities":["one","one","zeroOrOne","one","zeroOrOne","one","one","one","one","one"],"inheritedProperties":[{"baseType":"CALL_REPR","name":"NAME"},{"baseType":"CALL_REPR","name":"SIGNATURE"},{"baseType":"CALL_REPR","name":"COLUMN_NUMBER"},{"baseType":"EXPRESSION","name":"ARGUMENT_INDEX"},{"baseType":"CALL_REPR","name":"ORDER"},{"baseType":"CALL_REPR","name":"CODE"},{"baseType":"CALL_REPR","name":"LINE_NUMBER"}],"properties":["DISPATCH_TYPE","METHOD_FULL_NAME","TYPE_FULL_NAME"],"schema":"Ast","schemaIndex":7,"isAbstract":false,"containedNodes":[]},{"name":"CALL_REPR","comment":"A base class for nodes that represent different types of calls","extends":["CFG_NODE"],"allProperties":["CODE","COLUMN_NUMBER","LINE_NUMBER","NAME","ORDER","SIGNATURE"],"cardinalities":["one","zeroOrOne","zeroOrOne","one","one","one"],"inheritedProperties":[{"baseType":"CFG_NODE","name":"CODE"},{"baseType":"CFG_NODE","name":"COLUMN_NUMBER"},{"baseType":"CFG_NODE","name":"LINE_NUMBER"},{"baseType":"CFG_NODE","name":"ORDER"}],"properties":["NAME","SIGNATURE"],"schema":"Ast","schemaIndex":7,"isAbstract":true,"containedNodes":[]},{"name":"CONTROL_STRUCTURE","comment":"A control structure such as if, while, or for","extends":["EXPRESSION"],"allProperties":["ARGUMENT_INDEX","CODE","COLUMN_NUMBER","CONTROL_STRUCTURE_TYPE","LINE_NUMBER","ORDER","PARSER_TYPE_NAME"],"cardinalities":["one","one","zeroOrOne","one","zeroOrOne","one","one"],"inheritedProperties":[{"baseType":"EXPRESSION","name":"COLUMN_NUMBER"},{"baseType":"EXPRESSION","name":"ARGUMENT_INDEX"},{"baseType":"EXPRESSION","name":"ORDER"},{"baseType":"EXPRESSION","name":"CODE"},{"baseType":"EXPRESSION","name":"LINE_NUMBER"}],"properties":["CONTROL_STRUCTURE_TYPE","PARSER_TYPE_NAME"],"schema":"Ast","schemaIndex":7,"isAbstract":false,"containedNodes":[]},{"name":"EXPRESSION","comment":"Expression as a specialisation of tracking point","extends":["CFG_NODE","AST_NODE"],"allProperties":["ARGUMENT_INDEX","CODE","COLUMN_NUMBER","LINE_NUMBER","ORDER"],"cardinalities":["one","one","zeroOrOne","zeroOrOne","one"],"inheritedProperties":[{"baseType":"AST_NODE","name":"CODE"},{"baseType":"AST_NODE","name":"COLUMN_NUMBER"},{"baseType":"AST_NODE","name":"LINE_NUMBER"},{"baseType":"AST_NODE","name":"ORDER"}],"properties":["ARGUMENT_INDEX"],"schema":"Ast","schemaIndex":7,"isAbstract":true,"containedNodes":[]},{"name":"FIELD_IDENTIFIER","comment":"A node that represents which field is accessed in a <operator>.fieldAccess, in\ne.g. obj.field. The CODE part is used for human display and matching to MEMBER nodes.\nThe CANONICAL_NAME is used for dataflow tracking; typically both coincide.\nHowever, suppose that two fields foo and bar are a C-style union; then CODE refers\nto whatever the programmer wrote (obj.foo or obj.bar), but both share the same\nCANONICAL_NAME (e.g. GENERATED_foo_bar)","extends":["EXPRESSION"],"allProperties":["ARGUMENT_INDEX","CANONICAL_NAME","CODE","COLUMN_NUMBER","LINE_NUMBER","ORDER"],"cardinalities":["one","one","one","zeroOrOne","zeroOrOne","one"],"inheritedProperties":[{"baseType":"EXPRESSION","name":"COLUMN_NUMBER"},{"baseType":"EXPRESSION","name":"ARGUMENT_INDEX"},{"baseType":"EXPRESSION","name":"ORDER"},{"baseType":"EXPRESSION","name":"CODE"},{"baseType":"EXPRESSION","name":"LINE_NUMBER"}],"properties":["CANONICAL_NAME"],"schema":"Ast","schemaIndex":7,"isAbstract":false,"containedNodes":[]},{"name":"IDENTIFIER","comment":"An arbitrary identifier/reference","extends":["EXPRESSION","LOCAL_LIKE"],"allProperties":["ARGUMENT_INDEX","CODE","COLUMN_NUMBER","LINE_NUMBER","NAME","ORDER","TYPE_FULL_NAME"],"cardinalities":["one","one","zeroOrOne","zeroOrOne","one","one","one"],"inheritedProperties":[{"baseType":"LOCAL_LIKE","name":"NAME"},{"baseType":"EXPRESSION","name":"COLUMN_NUMBER"},{"baseType":"EXPRESSION","name":"ARGUMENT_INDEX"},{"baseType":"EXPRESSION","name":"ORDER"},{"baseType":"EXPRESSION","name":"CODE"},{"baseType":"EXPRESSION","name":"LINE_NUMBER"}],"properties":["TYPE_FULL_NAME"],"schema":"Ast","schemaIndex":7,"isAbstract":false,"containedNodes":[]},{"name":"JUMP_TARGET","comment":"A jump target made explicit in the code using a label","extends":["CFG_NODE","AST_NODE"],"allProperties":["ARGUMENT_INDEX","CODE","COLUMN_NUMBER","LINE_NUMBER","NAME","ORDER","PARSER_TYPE_NAME"],"cardinalities":["one","one","zeroOrOne","zeroOrOne","one","one","one"],"inheritedProperties":[{"baseType":"AST_NODE","name":"CODE"},{"baseType":"AST_NODE","name":"COLUMN_NUMBER"},{"baseType":"AST_NODE","name":"LINE_NUMBER"},{"baseType":"AST_NODE","name":"ORDER"}],"properties":["ARGUMENT_INDEX","NAME","PARSER_TYPE_NAME"],"schema":"Ast","schemaIndex":7,"isAbstract":false,"containedNodes":[]},{"name":"LITERAL","comment":"Literal/Constant","extends":["EXPRESSION"],"allProperties":["ARGUMENT_INDEX","CODE","COLUMN_NUMBER","LINE_NUMBER","ORDER","TYPE_FULL_NAME"],"cardinalities":["one","one","zeroOrOne","zeroOrOne","one","one"],"inheritedProperties":[{"baseType":"EXPRESSION","name":"COLUMN_NUMBER"},{"baseType":"EXPRESSION","name":"ARGUMENT_INDEX"},{"baseType":"EXPRESSION","name":"ORDER"},{"baseType":"EXPRESSION","name":"CODE"},{"baseType":"EXPRESSION","name":"LINE_NUMBER"}],"properties":["TYPE_FULL_NAME"],"schema":"Ast","schemaIndex":7,"isAbstract":false,"containedNodes":[]},{"name":"METHOD_INST","comment":"A method instance which always has to reference a method and may have type\nargument children if the referred to method is a template","extends":["AST_NODE"],"allProperties":["CODE","COLUMN_NUMBER","FULL_NAME","LINE_NUMBER","METHOD_FULL_NAME","NAME","ORDER","SIGNATURE"],"cardinalities":["one","zeroOrOne","one","zeroOrOne","one","one","one","one"],"inheritedProperties":[{"baseType":"AST_NODE","name":"CODE"},{"baseType":"AST_NODE","name":"COLUMN_NUMBER"},{"baseType":"AST_NODE","name":"LINE_NUMBER"},{"baseType":"AST_NODE","name":"ORDER"}],"properties":["FULL_NAME","METHOD_FULL_NAME","NAME","SIGNATURE"],"schema":"Ast","schemaIndex":7,"isAbstract":false,"containedNodes":[]},{"name":"METHOD_REF","comment":"Reference to a method instance","extends":["EXPRESSION"],"allProperties":["ARGUMENT_INDEX","CODE","COLUMN_NUMBER","LINE_NUMBER","METHOD_FULL_NAME","ORDER","TYPE_FULL_NAME"],"cardinalities":["one","one","zeroOrOne","zeroOrOne","one","one","one"],"inheritedProperties":[{"baseType":"EXPRESSION","name":"COLUMN_NUMBER"},{"baseType":"EXPRESSION","name":"ARGUMENT_INDEX"},{"baseType":"EXPRESSION","name":"ORDER"},{"baseType":"EXPRESSION","name":"CODE"},{"baseType":"EXPRESSION","name":"LINE_NUMBER"}],"properties":["METHOD_FULL_NAME","TYPE_FULL_NAME"],"schema":"Ast","schemaIndex":7,"isAbstract":false,"containedNodes":[]},{"name":"MODIFIER","comment":"A modifier, e.g., static, public, private","extends":["AST_NODE"],"allProperties":["CODE","COLUMN_NUMBER","LINE_NUMBER","MODIFIER_TYPE","ORDER"],"cardinalities":["one","zeroOrOne","zeroOrOne","one","one"],"inheritedProperties":[{"baseType":"AST_NODE","name":"CODE"},{"baseType":"AST_NODE","name":"COLUMN_NUMBER"},{"baseType":"AST_NODE","name":"LINE_NUMBER"},{"baseType":"AST_NODE","name":"ORDER"}],"properties":["MODIFIER_TYPE"],"schema":"Ast","schemaIndex":7,"isAbstract":false,"containedNodes":[]},{"name":"RETURN","comment":"A return instruction","extends":["EXPRESSION"],"allProperties":["ARGUMENT_INDEX","CODE","COLUMN_NUMBER","LINE_NUMBER","ORDER"],"cardinalities":["one","one","zeroOrOne","zeroOrOne","one"],"inheritedProperties":[{"baseType":"EXPRESSION","name":"COLUMN_NUMBER"},{"baseType":"EXPRESSION","name":"ARGUMENT_INDEX"},{"baseType":"EXPRESSION","name":"ORDER"},{"baseType":"EXPRESSION","name":"CODE"},{"baseType":"EXPRESSION","name":"LINE_NUMBER"}],"properties":[],"schema":"Ast","schemaIndex":7,"isAbstract":false,"containedNodes":[]},{"name":"TYPE_REF","comment":"Reference to a type/class","extends":["EXPRESSION"],"allProperties":["ARGUMENT_INDEX","CODE","COLUMN_NUMBER","LINE_NUMBER","ORDER","TYPE_FULL_NAME"],"cardinalities":["one","one","zeroOrOne","zeroOrOne","one","one"],"inheritedProperties":[{"baseType":"EXPRESSION","name":"COLUMN_NUMBER"},{"baseType":"EXPRESSION","name":"ARGUMENT_INDEX"},{"baseType":"EXPRESSION","name":"ORDER"},{"baseType":"EXPRESSION","name":"CODE"},{"baseType":"EXPRESSION","name":"LINE_NUMBER"}],"properties":["TYPE_FULL_NAME"],"schema":"Ast","schemaIndex":7,"isAbstract":false,"containedNodes":[]},{"name":"UNKNOWN","comment":"A language-specific node","extends":["EXPRESSION"],"allProperties":["ARGUMENT_INDEX","CODE","COLUMN_NUMBER","CONTAINED_REF","LINE_NUMBER","ORDER","PARSER_TYPE_NAME","TYPE_FULL_NAME"],"cardinalities":["one","one","zeroOrOne","one","zeroOrOne","one","one","one"],"inheritedProperties":[{"baseType":"EXPRESSION","name":"COLUMN_NUMBER"},{"baseType":"EXPRESSION","name":"ARGUMENT_INDEX"},{"baseType":"EXPRESSION","name":"ORDER"},{"baseType":"EXPRESSION","name":"CODE"},{"baseType":"EXPRESSION","name":"LINE_NUMBER"}],"properties":["CONTAINED_REF","PARSER_TYPE_NAME","TYPE_FULL_NAME"],"schema":"Ast","schemaIndex":7,"isAbstract":false,"containedNodes":[]},{"name":"CFG_NODE","comment":"Any node that can occur as part of a control flow graph","extends":["WITHIN_METHOD","AST_NODE"],"allProperties":["CODE","COLUMN_NUMBER","LINE_NUMBER","ORDER"],"cardinalities":["one","zeroOrOne","zeroOrOne","one"],"inheritedProperties":[{"baseType":"AST_NODE","name":"CODE"},{"baseType":"AST_NODE","name":"COLUMN_NUMBER"},{"baseType":"AST_NODE","name":"LINE_NUMBER"},{"baseType":"AST_NODE","name":"ORDER"}],"properties":[],"schema":"Cfg","schemaIndex":8,"isAbstract":true,"containedNodes":[]},{"name":"COMMENT","comment":"A source code comment","extends":[],"allProperties":["CODE","FILENAME","LINE_NUMBER"],"cardinalities":["one","one","zeroOrOne"],"inheritedProperties":[],"properties":["CODE","FILENAME","LINE_NUMBER"],"schema":"Comment","schemaIndex":12,"isAbstract":false,"containedNodes":[]},{"name":"CLOSURE_BINDING","comment":"Represents the binding of a LOCAL or METHOD_PARAMETER_IN into the closure of a method","extends":[],"allProperties":["CLOSURE_BINDING_ID","CLOSURE_ORIGINAL_NAME","EVALUATION_STRATEGY"],"cardinalities":["zeroOrOne","zeroOrOne","one"],"inheritedProperties":[],"properties":["CLOSURE_BINDING_ID","CLOSURE_ORIGINAL_NAME","EVALUATION_STRATEGY"],"schema":"Closure","schemaIndex":13,"isAbstract":false,"containedNodes":[]},{"name":"FINDING","extends":[],"allProperties":[],"cardinalities":[],"inheritedProperties":[],"properties":[],"schema":"Finding","schemaIndex":14,"isAbstract":false,"containedNodes":[{"name":"evidence","type":"ABSTRACT_NODE","cardinality":"list"},{"name":"keyValuePairs","type":"KEY_VALUE_PAIR","cardinality":"list"}]},{"name":"KEY_VALUE_PAIR","extends":[],"allProperties":["KEY","VALUE"],"cardinalities":["one","one"],"inheritedProperties":[],"properties":["KEY","VALUE"],"schema":"Finding","schemaIndex":14,"isAbstract":false,"containedNodes":[]},{"name":"LOCATION","extends":[],"allProperties":["CLASS_NAME","CLASS_SHORT_NAME","FILENAME","LINE_NUMBER","METHOD_FULL_NAME","METHOD_SHORT_NAME","NODE_LABEL","PACKAGE_NAME","SYMBOL"],"cardinalities":["one","one","one","zeroOrOne","one","one","one","one","one"],"inheritedProperties":[],"properties":["CLASS_NAME","CLASS_SHORT_NAME","FILENAME","LINE_NUMBER","METHOD_FULL_NAME","METHOD_SHORT_NAME","NODE_LABEL","PACKAGE_NAME","SYMBOL"],"schema":"TagsAndLocation","schemaIndex":16,"isAbstract":false,"containedNodes":[{"name":"node","type":"ABSTRACT_NODE","cardinality":"zeroOrOne"}]},{"name":"TAG","comment":"A string tag","extends":[],"allProperties":["NAME","VALUE"],"cardinalities":["one","one"],"inheritedProperties":[],"properties":["NAME","VALUE"],"schema":"TagsAndLocation","schemaIndex":16,"isAbstract":false,"containedNodes":[]},{"name":"TAG_NODE_PAIR","extends":[],"allProperties":[],"cardinalities":[],"inheritedProperties":[],"properties":[],"schema":"TagsAndLocation","schemaIndex":16,"isAbstract":false,"containedNodes":[{"name":"node","type":"ABSTRACT_NODE","cardinality":"one"},{"name":"tag","type":"TAG","cardinality":"one"}]},{"name":"DECLARATION","extends":[],"allProperties":["NAME"],"cardinalities":["one"],"inheritedProperties":[],"properties":["NAME"],"schema":"Base","schemaIndex":2147483647,"isAbstract":true,"containedNodes":[]},{"name":"LOCAL_LIKE","comment":"Formal input parameters, locals, and identifiers","extends":[],"allProperties":["NAME"],"cardinalities":["one"],"inheritedProperties":[],"properties":["NAME"],"schema":"Base","schemaIndex":2147483647,"isAbstract":true,"containedNodes":[]},{"name":"WITHIN_METHOD","comment":"Any node that can exist in a method","extends":[],"allProperties":[],"cardinalities":[],"inheritedProperties":[],"properties":[],"schema":"Base","schemaIndex":2147483647,"isAbstract":true,"containedNodes":[]}],"edges":[{"name":"ALIAS_OF","comment":"Alias relation between types. Created by backend passes.","schema":"Type"},{"name":"ARGUMENT","comment":"Relation between a CALL and its arguments and RETURN and the returned expression","schema":"CallGraph"},{"name":"AST","comment":"Syntax tree edge","schema":"Ast"},{"name":"BINDS","comment":"Relation between TYPE_DECL and BINDING node","schema":"Method"},{"name":"BINDS_TO","comment":"Type argument binding to a type parameter","schema":"Type"},{"name":"CALL","schema":"CallGraph"},{"name":"CAPTURE","comment":"Represents the capturing of a variable into a closure","schema":"Closure"},{"name":"CAPTURED_BY","comment":"Connection between a captured LOCAL and the corresponding CLOSURE_BINDING","schema":"Closure"},{"name":"CDG","comment":"Control dependency graph","schema":"Pdg"},{"name":"CFG","comment":"Control flow edge","schema":"Cfg"},{"name":"CONDITION","comment":"Edge from control structure node to the expression that holds the condition","schema":"Ast"},{"name":"CONTAINS","comment":"Shortcut over multiple AST edges","schema":"Shortcuts"},{"name":"DOMINATE","comment":"Points to dominated node in DOM tree","schema":"Dominators"},{"name":"EVAL_TYPE","comment":"Link to evaluation type","schema":"Shortcuts"},{"name":"INHERITS_FROM","comment":"Inheritance relation between types","schema":"Type"},{"name":"PARAMETER_LINK","comment":"Links together corresponding METHOD_PARAMETER_IN and METHOD_PARAMETER_OUT nodes. Created by backend.","schema":"Method"},{"name":"POST_DOMINATE","comment":"Points to dominated node in post DOM tree","schema":"Dominators"},{"name":"REACHING_DEF","comment":"Reaching definition edge","schema":"Pdg"},{"name":"RECEIVER","comment":"The receiver of a method call which is either an object or a pointer","schema":"CallGraph"},{"name":"REF","comment":"A reference to e.g. a LOCAL","schema":"Base"},{"name":"SOURCE_FILE","comment":"This edge connects a node to the node that represents its source file. These\nedges MUST not be created by the language frontend but are automatically\ncreated based on `FILENAME` fields.","schema":"FileSystem"},{"name":"TAGGED_BY","comment":"Edges from nodes to tags","schema":"TagsAndLocation"},{"name":"TYPE_DECL_ALIAS","comment":"Alias relation between two TYPE_DECL","schema":"Type"},{"name":"VTABLE","comment":"Indicates that a method is part of the vtable of a certain type declaration","schema":"Method"}],"properties":[{"name":"ALIAS_TYPE_FULL_NAME","comment":"Type full name of which a TYPE_DECL is an alias of","schema":"Type"},{"name":"ARGUMENT_INDEX","comment":"AST-children of CALL nodes have an argument index, that is used to match\ncall-site arguments with callee parameters. Explicit parameters are numbered\nfrom 1 to N, while index 0 is reserved for implicit self / this parameter.\nCALLs without implicit parameter therefore have arguments starting with index 1.\nAST-children of BLOCK nodes may have an argument index as well; in this case,\nthe last argument index determines the return-value of a BLOCK expression","schema":"CallGraph"},{"name":"AST_PARENT_FULL_NAME","comment":"The FULL_NAME of a the AST parent of an entity","schema":"Base"},{"name":"AST_PARENT_TYPE","comment":"The type of the AST parent. Since this is only used in some parts of the graph,\nthe list does not include all possible parents by intention.\nPossible parents: METHOD, TYPE_DECL, NAMESPACE_BLOCK.","schema":"Base"},{"name":"CANONICAL_NAME","comment":"Canonical token of a FIELD_IDENTIFIER. Typically identical to the CODE field,\nbut canonicalized according to source language semantics. Human readable names\nare preferable. FIELD_IDENTIFIERs must share identical CANONICAL_NAME if and\nonly if they alias, e.g. in C-style unions (if the aliasing relationship is\nunknown or there are partial overlaps, then one must make a reasonable guess,\nand trade off between false negatives and false positives)","schema":"Ast"},{"name":"CLASS_NAME","schema":"TagsAndLocation"},{"name":"CLASS_SHORT_NAME","schema":"TagsAndLocation"},{"name":"CLOSURE_BINDING_ID","comment":"Identifier which uniquely describes a CLOSURE_BINDING. This property is used to match captured LOCAL nodes with the corresponding CLOSURE_BINDING nodes","schema":"Closure"},{"name":"CLOSURE_ORIGINAL_NAME","comment":"The original name of the (potentially mangled) captured variable","schema":"Closure"},{"name":"CODE","comment":"The code snippet the node represents","schema":"Base"},{"name":"COLUMN_NUMBER","comment":"This optional fields provides the column number of the program construct\nrepresented by the node.","schema":"FileSystem"},{"name":"COLUMN_NUMBER_END","comment":"This optional fields provides the column number at which the program construct\nrepresented by the node ends.","schema":"FileSystem"},{"name":"CONTAINED_REF","comment":"References to other nodes. This is not a real property; it exists here for the sake of proto serialization only. valueType and cardinality are meaningless.","schema":"ProtoSerialize"},{"name":"CONTROL_STRUCTURE_TYPE","comment":"Indicates the control structure type. See controlStructureTypes","schema":"Ast"},{"name":"DISPATCH_TYPE","comment":"The dispatch type of a call, which is either static or dynamic. See dispatchTypes","schema":"CallGraph"},{"name":"EVALUATION_STRATEGY","comment":"Evaluation strategy for function parameters and return values. One of the values in \"evaluationStrategies\"","schema":"CallGraph"},{"name":"FILENAME","comment":"The absolute path of the source file this node was generated from. This field\nmust be set but may be set to the value `<unknown>` to indicate that no source\nfile can be associated with the node, e.g., because the node represents an\nentity known to exist because it is referenced, but for which the file that\nis is declared in is unknown.","schema":"FileSystem"},{"name":"FULL_NAME","comment":"Full name of an element, e.g., the class name along, including its package\n(e.g. \\\"io.shiftleft.dataflowenging.layers.dataflows.DataFlowRunner.run\\\").\nIn theory, the FULL_NAME just needs to be unique and is used for linking references,\nso a consecutive integer would be valid. In practice, this should be human readable","schema":"Base"},{"name":"HASH","comment":"This property contains a hash value in the form of a string.\nHashes can be used to summarize data, e.g., to summarize the\ncontents of source files or sub graphs. Such summaries are useful\nto determine whether code has already been analyzed in incremental\nanalysis pipelines. This property is optional to allow its calculation\nto be deferred or skipped if the hash is not needed.","schema":"Base"},{"name":"INHERITS_FROM_TYPE_FULL_NAME","comment":"The static types a TYPE_DECL inherits from. This property is matched against the\nFULL_NAME of TYPE nodes and thus it is required to have at least one TYPE node\nfor each TYPE_FULL_NAME","schema":"Type"},{"name":"IS_EXTERNAL","comment":"Indicates that the construct (METHOD or TYPE_DECL) is external, that is,\nit is referenced but not defined in the code (applies both to insular\nparsing and to library functions where we have header files only)","schema":"Base"},{"name":"IS_METHOD_NEVER_OVERRIDDEN","comment":"True if the referenced method is never overridden by the subclasses and false otherwise. This can be left blank by the frontend.","schema":"Method"},{"name":"KEY","schema":"Finding"},{"name":"LANGUAGE","comment":"This field indicates which CPG language frontend generated the CPG.\nFrontend developers may freely choose a value that describes their frontend\nso long as it is not used by an existing frontend. Reserved values are to date:\nC, LLVM, GHIDRA, PHP.","schema":"MetaData"},{"name":"LINE_NUMBER","comment":"This optional field provides the line number of the program construct\nrepresented by the node.","schema":"FileSystem"},{"name":"LINE_NUMBER_END","comment":"This optional fields provides the line number at which the program construct\nrepresented by the node ends.","schema":"FileSystem"},{"name":"METHOD_FULL_NAME","comment":"The FULL_NAME of a method. Used to link CALL and METHOD nodes. It is required\nto have exactly one METHOD node for each METHOD_FULL_NAME","schema":"Ast"},{"name":"METHOD_SHORT_NAME","schema":"TagsAndLocation"},{"name":"MODIFIER_TYPE","comment":"Indicates the modifier which is represented by a MODIFIER node. See modifierTypes","schema":"Ast"},{"name":"NAME","comment":"Name of represented object, e.g., method name (e.g. \"run\")","schema":"Base"},{"name":"NODE_LABEL","schema":"TagsAndLocation"},{"name":"ORDER","comment":"General ordering property, such that the children of each AST-node are\ntypically numbered from 1, ..., N (this is not enforced).","schema":"Base"},{"name":"OVERLAYS","comment":"The field contains the names of the overlays applied to this CPG, in order of their\napplication. Names are free-form strings, that is, this specification does not\ndictate them but rather requires tool producers and consumers to communicate them\nbetween each other.","schema":"MetaData"},{"name":"PACKAGE_NAME","schema":"TagsAndLocation"},{"name":"PARSER_TYPE_NAME","comment":"AST node type name emitted by parser.","schema":"Base"},{"name":"SIGNATURE","comment":"Method signature. The format is defined by the language front-end, and the\nbackend simply compares strings to resolve function overloading, i.e. match\ncall-sites to METHODs. In theory, consecutive integers would be valid,\nbut in practice this should be human readable","schema":"Method"},{"name":"SYMBOL","schema":"TagsAndLocation"},{"name":"TYPE_DECL_FULL_NAME","comment":"The static type decl of a TYPE. This property is matched against the FULL_NAME\nof TYPE_DECL nodes. It is required to have exactly one TYPE_DECL for each\ndifferent TYPE_DECL_FULL_NAME","schema":"Type"},{"name":"TYPE_FULL_NAME","comment":"The static type of an entity. E.g. expressions, local, parameters etc.\nThis property is matched against the FULL_NAME of TYPE nodes and thus it\nis required to have at least one TYPE node for each TYPE_FULL_NAME","schema":"Type"},{"name":"VALUE","comment":"Generic node property","schema":"Base"},{"name":"VARIABLE","comment":"A variable propagated by a reaching-def edge","schema":"Pdg"},{"name":"VERSION","comment":"A version, given as a string. Used, for example, in the META_DATA node to\nindicate which version of the CPG spec this CPG conforms to","schema":"Base"}]}