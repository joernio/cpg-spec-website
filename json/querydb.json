[{"name":"setgid-without-setgroups","author":"@maltek","title":"Process group membership is changed without setting ancillary groups first","description":"\nThe set*gid system calls do not affect the ancillary groups a process belongs to.\nChanges to the group membership should therefore always be preceded by a call to setgroups.\nOtherwise the process may still be a secondary member of the group it tries to disavow.\n","score":2.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg\n          .method(\"(?i)set(res|re|e|)gid\")\n          .callIn\n          .whereNot(_.dominatedBy.isCall.name(\"setgroups\"))","tags":["setxid","default"],"language":"c","codeExamples":{"positive":["\n\nvoid good() {\n  setgroups();\n  setresgid();\n  setresuid();\n}\n\n"],"negative":["\n\nvoid bad2() {\n  setresgid();\n  setresuid();\n}\n\n"]}},{"name":"setuid-without-setgid","author":"@maltek","title":"Process user ID is changed without changing groups first","description":"\nThe set*uid system calls do not affect the groups a process belongs to. However, often\nthere exists a group that is equivalent to a user (e.g. wheel or shadow groups are often\nequivalent to the root user).\nGroup membership can only be changed by the root user.\nChanges to the user should therefore always be preceded by calls to set*gid and setgroups,\n","score":2.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg\n          .method(\"(?i)set(res|re|e|)uid\")\n          .callIn\n          .whereNot(_.dominatedBy.isCall.name(\"set(res|re|e|)?gid\"))","tags":["setxid","default"],"language":"c","codeExamples":{"positive":["\n\nvoid good() {\n  setgroups();\n  setresgid();\n  setresuid();\n}\n\n"],"negative":["\n\nvoid bad1() {\n  setresuid();\n}\n\nvoid bad3() {\n  setgroups();\n  setresuid();\n}\n\n"]}},{"name":"constant-array-access-no-check","author":"@fabsx00","title":"Array access at fixed offset but sufficient length check not determined","description":"\n\n","score":3.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method.arrayAccess\n          .filter { access =>\n            val arrName = access.simpleName\n            arrName.isDefined && !arrName.forall(x =>\n              access.method.local.nameExact(x).nonEmpty)\n          }\n          .usesConstantOffset\n          .flatMap { arrayAccess =>\n            val lenFields =\n              potentialLengthFields(arrayAccess, arrayAccess.method)\n            if (lenFields.nonEmpty) {\n              List((arrayAccess, lenFields))\n            } else {\n              List()\n            }\n          }\n          .collect {\n            case (arrayAccess, lenFields) if !checked(arrayAccess, lenFields) =>\n              arrayAccess\n          }","tags":["default"],"language":"c","codeExamples":{"positive":[],"negative":[]}},{"name":"strncpy-no-null-term","author":"@fabsx00","title":"strncpy is used and no null termination is nearby","description":"\n Upon calling `strncpy` with a source string that is larger\n than the destination buffer, the destination buffer is not\n null-terminated by `strncpy` and there is no explicit\n null termination nearby. This is unproblematic if the\n buffer size is at least 1 larger than the size passed\n to `strncpy`.\n","score":4.0,"traversal":{},"traversalAsString":"cpg =>\n        val allocations = cpg.method(\".*malloc$\").callIn.argument(1).l\n        cpg\n          .method(\"(?i)strncpy\")\n          .callIn\n          .map { c =>\n            (c.method, c.argument(1), c.argument(3))\n          }\n          .filter {\n            case (method, dst, size) =>\n              dst.reachableBy(allocations).codeExact(size.code).nonEmpty &&\n                method.assignments\n                  .where(_.target.isArrayAccess.code(s\"${dst.code}.*\\\\[.*\"))\n                  .source\n                  .isLiteral\n                  .code(\".*0.*\")\n                  .isEmpty\n          }\n          .map(_._2)","tags":["strings","default"],"language":"c","codeExamples":{"positive":["\n\n// If src points to a string that is at least `asize` long,\n// then `ptr` will not be null-terminated after the `strncpy`\n// call.\nint bad() {\n  char *ptr = malloc(asize);\n  strncpy(ptr, src, asize);\n}\n\n"],"negative":["\n\n// Null-termination is ensured if we can only copy\n// less than `asize + 1` into the buffer\nint good() {\n  char *ptr = malloc(asize + 1);\n  strncpy(ptr, src, asize);\n}\n\n // Null-termination is also ensured if it is performed\n // explicitly\nint alsogood() {\n  char *ptr = malloc(asize);\n  strncpy(ptr, src, asize);\n  ptr[asize -1] = '\\0';\n}\n\n"]}},{"name":"malloc-memcpy-int-overflow","author":"@fabsx00","title":"Dangerous copy-operation into heap-allocated buffer","description":"-","score":4.0,"traversal":{},"traversalAsString":"cpg =>\n        val src =\n          cpg.method(\".*malloc$\").callIn.where(_.argument(1).arithmetics).l\n\n        cpg.method(\"(?i)memcpy\").callIn.l.filter { memcpyCall =>\n          memcpyCall\n            .argument(1)\n            .reachableBy(src)\n            .where(_.inAssignment.target.codeExact(memcpyCall.argument(1).code))\n            .whereNot(_.argument(1).codeExact(memcpyCall.argument(3).code))\n            .hasNext\n        }","tags":["integers","default"],"language":"c","codeExamples":{"positive":["\n\nint vulnerable(size_t len, char *src) {\n  char *dst = malloc(len + 8);\n  memcpy(dst, src, len + 7);\n}\n\n"],"negative":["\n\nint non_vulnerable(size_t len, char *src) {\n char *dst = malloc(len + 8);\n memcpy(dst, src,len + 8);\n}\n\nint non_vulnerable2(size_t len, char *src) {\n char *dst = malloc( some_size );\n assert(dst);\n memcpy(dst, src, some_size );\n}\n\n"]}},{"name":"too-nested","author":"@fabsx00","title":"Nesting level higher than 3","description":"This query identifies functions with a nesting level higher than 3","score":1.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method.internal.filter(_.depth(_.isControlStructure) > n)","tags":["metrics"],"language":"c","codeExamples":{"positive":["\n\nint func_with_nesting_level_of_3(int foo, int bar) {\n  if (foo > 10) {\n    if (bar > foo) {\n      for(int i = 0; i < bar ;i++) {\n\n      }\n    }\n  }\n}\n\n"],"negative":[]}},{"name":"too-many-loops","author":"@fabsx00","title":"More than 4 loops","description":"This query identifies functions with more than 4 loops","score":1.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method.internal\n          .filter(\n            _.ast.isControlStructure\n              .parserTypeName(\"(For|Do|While).*\")\n              .size > n)","tags":["metrics"],"language":"c","codeExamples":{"positive":["\n\nint high_number_of_loops () {\n  for(int i = 0; i < 10; i++){\n  }\n  int j = 0;\n  do {\n    j++\n  } while(j < 10);\n  while(foo()) {}\n  while(bar()){}\n}\n"],"negative":[]}},{"name":"multiple-returns","author":"@fabsx00","title":"Multiple returns","description":"This query identifies functions with more than one return","score":1.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method.internal.filter(_.ast.isReturn.l.size > 1)","tags":["metrics"],"language":"c","codeExamples":{"positive":["\n\nint func_with_multiple_returns (int x) {\n  if (x > 10) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\n\n"],"negative":[]}},{"name":"too-long","author":"@fabsx00","title":"More than 1000 lines","description":"This query identifies functions that are more than 1000 lines long","score":1.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method.internal.filter(_.numberOfLines > n)","tags":["metrics"],"language":"c","codeExamples":{"positive":["\n\nint func_with_many_lines(int x) {\n  x++;\n  x++;\n  x++;\n  x++;\n  x++;\n  x++;\n  x++;\n  x++;\n  x++;\n  x++;\n  x++;\n  x++;\n}\n\n"],"negative":[]}},{"name":"too-high-complexity","author":"@fabsx00","title":"Cyclomatic complexity higher than 4","description":"This query identifies functions with a cyclomatic complexity higher than 4","score":1.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method.internal.filter(_.controlStructure.size > n)","tags":["metrics"],"language":"c","codeExamples":{"positive":["\n\nint high_cyclomatic_complexity(int x) {\n  while(true) {\n    for(int i = 0; i < 10; i++) {\n    }\n    if(foo()) {}\n  }\n  if (x > 10) {\n    for(int i = 0; i < 10; i++) {\n\n     }\n  }\n}\n\n"],"negative":[]}},{"name":"too-many-params","author":"@fabsx00","title":"Number of parameters larger than 4","description":"This query identifies functions with more than 4 formal parameters","score":1.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method.internal.filter(_.parameter.size > n)","tags":["metrics"],"language":"c","codeExamples":{"positive":["\n\nint too_many_params(int a, int b, int c, int d, int e) {\n\n}\n\n"],"negative":[]}},{"name":"socket-send","author":"@fabsx00","title":"Unchecked call to send","description":"\n When calling `send`, the return value must be checked to determine\n if the send operation was successful and how many bytes were\n transmitted.\n","score":2.0,"traversal":{},"traversalAsString":"cpg =>\n        implicit val noResolve: NoResolve.type = NoResolve\n        cpg\n          .method(\"send\")\n          .filter(_.parameter.size == 4)\n          .callIn\n          .returnValueNotChecked","tags":["default","posix"],"language":"c","codeExamples":{"positive":[],"negative":[]}},{"name":"free-follows-value-reuse","author":"@maltek","title":"A value that is free'd is reused without reassignment.","description":"\nA value is used after being free'd in a path that leads to it\nwithout reassignment.\n\nModeled after CVE-2019-18903.\n","score":5.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method\n          .name(\"(.*_)?free\")\n          .filter(_.parameter.size == 1)\n          .callIn\n          .where(_.argument(1).isIdentifier)\n          .flatMap(f => {\n            val freedIdentifierCode = f.argument(1).code\n            val postDom = f.postDominatedBy.toSet\n\n            val assignedPostDom = postDom.isIdentifier\n              .where(_.inAssignment)\n              .codeExact(freedIdentifierCode)\n              .flatMap(id => id ++ id.postDominatedBy)\n\n            postDom\n              .removedAll(assignedPostDom)\n              .isIdentifier\n              .codeExact(freedIdentifierCode)\n          })","tags":["uaf"],"language":"c","codeExamples":{"positive":["\n\nvoid *bad() {\n  void *x = NULL;\n  if (cond)\n    free(x);\n  return x;\n}\n\nvoid *false_positive() {\n  void *x = NULL;\n  free(x);\n  if (cond)\n    x = NULL;\n  else\n    x = NULL;\n  return x;\n}\n\n"],"negative":["\n\nvoid *false_negative() {\n  void *x = NULL;\n  if (cond) {\n    free(x);\n    if (cond2)\n      return x; // not post-dominated by free call\n    x = NULL;\n  }\n  return x;\n}\n\nvoid *good() {\n  void *x = NULL;\n  if (cond)\n    free(x);\n  x = NULL;\n  return x;\n}\n\n"]}},{"name":"free-returned-value","author":"@maltek","title":"A value that is returned through a parameter is free'd in a path","description":"\nThe function sets a field of a function parameter to a value of a local\nvariable.\nThis variable is then freed in some paths. Unless the value set in the\nfunction |parameter is overridden later on, the caller has access to the\nfree'd memory, which is undefined behavior.\n\nFinds bugs like CVE-2019-18902.\n","score":5.0,"traversal":{},"traversalAsString":"cpg =>\n        def outParams =\n          cpg.parameter\n            .typeFullName(\".+\\\\*\")\n            .whereNot(\n              _.referencingIdentifiers\n                .argumentIndex(1)\n                .inCall\n                .nameExact(Operators.assignment, Operators.addressOf))\n\n        def assignedValues =\n          outParams.referencingIdentifiers\n            .argumentIndex(1)\n            .inCall\n            .nameExact(Operators.indirectFieldAccess,\n                       Operators.indirection,\n                       Operators.indirectIndexAccess)\n            .argumentIndex(1)\n            .inCall\n            .nameExact(Operators.assignment)\n            .argument(2)\n            .isIdentifier\n\n        def freeAssigned =\n          assignedValues.map(\n            id =>\n              (id,\n               id.refsTo\n                 .flatMap {\n                   case p: MethodParameterIn => p.referencingIdentifiers\n                   case v: Local             => v.referencingIdentifiers\n                 }\n                 .inCall\n                 .name(\"(.*_)?free\")))\n\n        freeAssigned\n          .filter {\n            case (id, freeCall) => freeCall.dominatedBy.exists(_ == id)\n          }\n          .flatMap(_._1)","tags":["uaf"],"language":"c","codeExamples":{"positive":["\n\nvoid bad(a_struct_type *a_struct) {\n  void *x = NULL;\n  a_struct->foo = x;\n  free(x);\n}\n\n"],"negative":["\n\nvoid good1(a_struct_type *a_struct) {\n  void *x = NULL, *y = NULL;\n  a_struct->foo = x;\n  free(y);\n}\n\nvoid good2(a_struct_type *a_struct) {\n  void *x = NULL;\n  free(a_struct->foo);\n  a_struct->foo = x;\n}\n\nvoid bad_not_covered(a_struct_type *a_struct) {\n  void *x = NULL;\n  a_struct->foo = x;\n  free(a_struct->foo);\n}\n\n"]}},{"name":"free-field-no-reassign","author":"@fabsx00","title":"A field of a parameter is free'd and not reassigned on all paths","description":"\n The function is able to modify a field of a structure passed in by\n the caller. It frees this field and does not guarantee that on\n all paths to the exit, the field is reassigned. If any\n caller now accesses the field, then it accesses memory that is no\n longer allocated. We also check that the function does not free\n or clear the entire structure, as in that case, it is unlikely that the\n passed in structure will be used again.\n","score":5.0,"traversal":{},"traversalAsString":"cpg =>\n        val freeOfStructField = cpg\n          .method(\"free\")\n          .callIn\n          .where(\n            _.argument(1)\n              .isCallTo(\"<operator>.*[fF]ieldAccess.*\")\n              .filter(x =>\n                x.method.parameter.name.toSet.contains(x.argument(1).code))\n          )\n          .whereNot(_.argument(1).isCall.argument(1).filter { struct =>\n            struct.method.ast.isCall\n              .name(\".*free$\", \"memset\", \"bzero\")\n              .argument(1)\n              .codeExact(struct.code)\n              .nonEmpty\n          })\n          .l\n\n        freeOfStructField.argument(1).filter { arg =>\n          arg.method.methodReturn.reachableBy(arg).nonEmpty\n        }","tags":["uaf","default"],"language":"c","codeExamples":{"positive":["\n\nvoid free_field_reassigned(a_struct_type *a_struct) {\n  free(a_struct->ptr);\n  if (something) {\n    return;\n  }\n  a_struct->ptr = foo;\n}\n\n"],"negative":["\n\nvoid not_free_field_reassigned(a_struct_type *a_struct) {\n  free(a_struct->ptr);\n  if (something) {\n    a_struct->ptr = NULL;\n    return;\n  }\n  a_struct->ptr = foo;\n}\n\n"]}},{"name":"unchecked-read-recv-malloc","author":"@fabsx00","title":"Unchecked read/recv/malloc","description":"\nThe return value of a read/recv/malloc call is not checked directly and\nthe variable it has been assigned to (if any) does not\noccur in any check within the caller.\n","score":3.0,"traversal":{},"traversalAsString":"cpg =>\n        implicit val noResolve: NoResolve.type = NoResolve\n        cpg\n          .method(\"(?i)(read|recv|malloc)\")\n          .callIn\n          .returnValueNotChecked","tags":["default"],"language":"c","codeExamples":{"positive":["\n\nvoid unchecked_read() {\n  read(fd, buf, sizeof(buf));\n}\n\nvoid checks_something_else() {\n  int nbytes = read(fd, buf, sizeof(buf));\n  if( foo != sizeof(buf)) {\n\n  }\n}\n\n"],"negative":["\n\nvoid checked_after_assignment() {\n  int nbytes = read(fd, buf, sizeof(buf));\n  if( nbytes != sizeof(buf)) {\n\n  }\n}\n\nvoid immediately_checked() {\n  if ( (read(fd, buf, sizeof(buf))) != sizeof(buf)) {\n\n  }\n}\n\nint notCheckedButDirectlyReturned() {\n  return read(fd, buf, sizeof(buf));\n}\n\n"]}},{"name":"call-to-exec","author":"@0x4D5A","title":"Dangerous function 'java.lang.Runtime.exec:java.lang.Process(java.lang.String)' used","description":"\n A call to the function `java.lang.Runtime.exec:java.lang.Process(java.lang.String)` \n could result in a potential remote code execution.\n","score":8.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method(\"java.lang.Runtime.exec\").callIn","tags":["badfn","default"],"language":"java","codeExamples":{"positive":[],"negative":[]}},{"name":"sql-injection","author":"@0x4D5A","title":"SQL injection: A parameter is used in an insecure database API call.","description":"\nAn attacker controlled parameter is used in an insecure database API call.\n\nIf the parameter is not validated and sanitized, this is a SQL injection.\n","score":5.0,"traversal":{},"traversalAsString":"cpg =>\n        def source =\n          cpg.method\n            .where(_.methodReturn.evalType(\n              \"org.springframework.web.servlet.ModelAndView\"))\n            .parameter\n\n        def sink = cpg.method.name(\"query\").parameter.order(1)\n\n        sink.reachableBy(source).l","tags":["sql-injection","default"],"language":"java","codeExamples":{"positive":[],"negative":[]}},{"name":"call-to-getwd","author":"@ursachec","title":"Dangerous function getwd() used","description":"\n Avoid the `getwd` function, it does not check buffer lengths.\n Use `getcwd` instead, as it checks the buffer size.\n","score":4.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method(\"(?i)getwd\").callIn","tags":["badfn","default"],"language":"c","codeExamples":{"positive":["\n\nint insecure_getwd() {\n  char dir[12];\n  getwd(dir);\n  printf(\"Working directory:%s\\n\",dir);\n  return 0;\n}\n\n"],"negative":[]}},{"name":"call-to-strtok","author":"@tuxology","title":"Dangerous function strtok() used","description":"\n Avoid `strtok` function as it modifies the original string in place\n and appends a null character after each token. This makes the\n original string unsafe. Suggested alternative is `strtok_r` with\n `saveptr`.\n","score":4.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method(\"(?i)strtok\").callIn","tags":["badfn","default"],"language":"c","codeExamples":{"positive":["\n\nint insecure_strtok() {\n  char *token;\n  char *path = getenv(\"PATH\");\n  token = strtok(path, \":\");\n  puts(token);\n  printf(\"PATH: %s\\n\", path); // original path string now has '/usr/bin\\0' now and is insecure to use\n  return 0;\n}\n\n"],"negative":[]}},{"name":"call-to-strcpy","author":"@tuxology","title":"Dangerous functions `strcpy` or `strncpy` used","description":"\n Avoid `strcpy` or `strncpy` function. `strcpy` does not check buffer\n lengths.\n A possible mitigation could be `strncpy` which could prevent\n buffer overflows but does not null-terminate strings leading to\n memory corruption. A secure alternative (on BSD) is `strlcpy`.\n","score":4.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method(\"(?i)(strcpy|strncpy)\").callIn","tags":["badfn"],"language":"c","codeExamples":{"positive":["\n\nint insecure_strncpy() {\n  char buf[BUF_SIZE];\n  strncpy(buf, default_value, BUF_SIZE); // remediation is (BUFF_SIZE - 1)\n  return 0\n}\n\n"],"negative":[]}},{"name":"call-to-strcat","author":"@tuxology","title":"Dangerous functions `strcat` or `strncat` used","description":"\n Avoid `strcat` or `strncat` functions. These can be used insecurely\n causing non null-termianted strings leading to memory corruption.\n A secure alternative is `strcat_s`.\n","score":4.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method(\"(?i)(strcat|strncat)\").callIn","tags":["badfn"],"language":"c","codeExamples":{"positive":["\n\nint insecure_strncat() {\n  char buf[BUF_SIZE];\n  strncat(buf, another_buffer, BUF_SIZE - strlen(buf)); // remediation is (BUFF_SIZE - strlen(buf) - 1)\n  return 0\n}\n\n"],"negative":[]}},{"name":"call-to-scanf","author":"@tuxology","title":"Insecure function scanf() used","description":"\n Avoid `scanf` function as it can lead to reads beyond buffer\n boundary and cause buffer overflows. A secure alternative is `fgets`.\n","score":4.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method(\"(?i)scanf\").callIn","tags":["badfn"],"language":"c","codeExamples":{"positive":["\n\nint insecure_scanf() {\n  char name[12];\n  scanf(\"%s\", name);\n  printf(\"Hello %s!\\n\", name);\n  return 0\n}\n\n"],"negative":[]}},{"name":"format-controlled-printf","author":"@tuxology","title":"Non-constant format string passed to printf/sprintf/vsprintf","description":"\n Avoid user controlled format strings like \"argv\" in printf, sprintf and vsprintf \n functions as they can cause memory corruption. Some secure\n alternatives are `snprintf` and `vsnprintf`.\n","score":4.0,"traversal":{},"traversalAsString":"cpg =>\n        val printfFns = cpg\n          .method(\"(?i)printf\")\n          .callIn\n          .whereNot(_.argument.order(1).isLiteral)\n        val sprintsFns = cpg\n          .method(\"(?i)(sprintf|vsprintf)\")\n          .callIn\n          .whereNot(_.argument.order(2).isLiteral)\n        (printfFns ++ sprintsFns)","tags":["badfn","default"],"language":"c","codeExamples":{"positive":["\nint insecure_printf() {\n  printf(argv[1], 4242);\n\n}\n","\n\nint insecure_sprintf() {\n  char buffer [BUFF_SIZE];\n  sprintf(buffer, argv[2], 4242);\n}\n\n"],"negative":["\n\nint secure_printf() {\n  printf(\"Num: %d\", 4242);\n}\n\n","\n\nint secure_sprintf() {\n  char buffer [BUFF_SIZE];\n  snprintf(buffer, BUFF_SIZE, argv[2], 4242);\n}\n\n"]}},{"name":"call-to-gets","author":"@tuxology","title":"Dangerous function gets() used","description":"\n Avoid `gets` function as it can lead to reads beyond buffer\n boundary and cause\n buffer overflows. Some secure alternatives are `fgets` and `gets_s`.\n","score":8.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method(\"(?i)gets\").callIn","tags":["badfn","default"],"language":"c","codeExamples":{"positive":["\n\nint insecure_gets() {\n  char str[DST_BUFFER_SIZE];\n  gets(str);\n  printf(\"%s\", str);\n  return 0;\n}\n\n"],"negative":["\n\nint secure_gets() {\n  FILE *fp;\n  fp = fopen(\"file.txt\" , \"r\");\n  char str[DST_BUFFER_SIZE];\n  fgets(str, DST_BUFFER_SIZE, fp);\n  printf(\"%s\", str);\n  return 0;\n}\n\n"]}},{"name":"ineffective-certificate-check","author":"@maltek","title":"Ineffective Certificate Validation: The validation result is always positive","description":"\nA certificate validation function is implemented as a function that only consists of a prologue where local\nvariables are initialized to arguments, followed by a (positive) return statement.\n","score":6.0,"traversal":{},"traversalAsString":"cpg =>\n        val validators = Map(\n          // javax.net.ssl.HostnameVerifier\n          \"verify\" -> \"boolean(java.lang.String,javax.net.ssl.SSLSession)\",\n          // javax.net.ssl.X509ExtendedTrustManager\n          \"checkClientTrusted\" -> \"void(java.security.cert.X509Certificate[],java.lang.String,java.net.Socket)\",\n          \"checkClientTrusted\" -> \"void(java.security.cert.X509Certificate[],java.lang.String,javax.net.ssl.SSLEngine)\",\n          \"checkServerTrusted\" -> \"void(java.security.cert.X509Certificate[],java.lang.String,java.net.Socket)\",\n          \"checkServerTrusted\" -> \"void(java.security.cert.X509Certificate[],java.lang.String,javax.net.ssl.SSLEngine)\",\n        )\n\n        // skip over arguments getting copied to local variables\n        def isPrologue(node: nodes.CfgNode): Boolean = node match {\n          case id: nodes.Identifier =>\n            id.refsTo.forall(_.isInstanceOf[nodes.Local])\n          case c: nodes.Call =>\n            c.methodFullName == Operators.assignment && c.argument.forall(\n              isPrologue\n            )\n          case _ => false\n        }\n        def skipPrologue(node: nodes.CfgNode): Traversal[nodes.CfgNode] =\n          node.repeat(_.cfgNext)(_.until(_.filter(!isPrologue(_))))\n\n        cpg.method\n          .nameExact(validators.keys.toSeq: _*)\n          .signatureExact(validators.values.toSeq: _*)\n          .cfgFirst\n          .flatMap(skipPrologue)\n          .filter {\n            case lit: nodes.Literal =>\n              lit.code == \"1\" && lit.cfgNext\n                .forall(_.isInstanceOf[nodes.Return])\n            case _: nodes.Return => true\n            case _               => false\n          }","tags":["badimpl","default"],"language":"java","codeExamples":{"positive":[],"negative":[]}},{"name":"xss-servlet","author":"@maltek","title":"Reflected Cross-Site Scripting: Servlet Returns HTTP Input in Response","description":"\nA servlet returns a URL parameter as part of the response.\n\nUnless the parameter is escaped or validated in-between, this is a reflected XSS vulnerability.\n","score":8.0,"traversal":{},"traversalAsString":"cpg =>\n        def source =\n          cpg.call.methodFullNameExact(\n            \"javax.servlet.http.HttpServletRequest.getParameter:java.lang.String(java.lang.String)\"\n          )\n\n        def responseWriter =\n          cpg.call.methodFullNameExact(\n            \"javax.servlet.http.HttpServletResponse.getWriter:java.io.PrintWriter()\"\n          )\n\n        def sinks =\n          cpg.call\n            .methodFullNameExact(\n              \"java.io.PrintWriter.println:void(java.lang.String)\"\n            )\n            .where(_.argument(0).reachableBy(responseWriter))\n\n        sinks.where(_.argument(1).reachableBy(source))","tags":["xss","default"],"language":"java","codeExamples":{"positive":[],"negative":[]}},{"name":"signed-left-shift","author":"@maltek","title":"Signed Shift May Cause Undefined Behavior","description":"\nSigned integer overflow is undefined behavior. Shifts of signed values to the\nleft are very prone to overflow.\n","score":2.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.call\n          .nameExact(Operators.shiftLeft, Operators.assignmentShiftLeft)\n          .where(_.argument(1).typ.fullNameExact(\"int\", \"long\"))\n          .filterNot(_.argument.isLiteral.size == 2)","tags":["integers","default"],"language":"c","codeExamples":{"positive":["\n\nvoid bad1(int val) {\n  val <<= 24;\n}\n\nvoid bad2(int val) {\n  255 << val;\n}\n\nvoid bad3(int val) {\n  val << val;\n}\n"],"negative":["\n\nvoid good(unsigned int val) {\n  255 << 24; // we ignore signed shift with two literals\n  val <<= 24;\n  val << val;\n}\n\n"]}},{"name":"copy-loop","author":"@fabsx00","title":"Copy loop detected","description":"\nFor (buf, indices) pairs, determine those inside control structures (for, while, if ...)\nwhere any of the calls made outside of the body (block) are Inc operations. Determine\nthe first argument of that Inc operation and check if they are used as indices for\nthe write operation into the buffer.\n","score":2.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.assignment.target.isArrayAccess\n          .map { access =>\n            (access.array, access.subscripts.code.toSet)\n          }\n          .filter {\n            case (buf, subscripts) =>\n              val incIdentifiers = buf.inAst.isControlStructure.astChildren\n                .filterNot(_.isBlock)\n                .assignments\n                .target\n                .code\n                .toSet\n              (incIdentifiers & subscripts).nonEmpty\n          }\n          .map(_._1)","tags":[],"language":"c","codeExamples":{"positive":["\n\nint index_into_dst_array (char *dst, char *src, int offset) {\n  for(i = 0; i < strlen(src); i++) {\n    dst[i + + j*8 + offset] = src[i];\n  }\n}\n\n"],"negative":["\n\n// We do not want to detect this one because the\n// index only specifies where to read from\nint index_into_src_array() {\n  for(i = 0; i < strlen(src); i++) {\n    dst[k] = src[i];\n  }\n}\n\n"]}},{"name":"file-operation-race","author":"@maltek","title":"Two file operations on the same path can act on different files","description":"\nTwo subsequent file operations are performed on the same path. Depending on the permissions\non this path, an attacker can exploit a race condition and replace the file or directory\nthe path refers to between these calls.\nUse file operations based on file descriptor/pointer/handles instead of paths to avoid this issue.\n","score":3.0,"traversal":{},"traversalAsString":"cpg =>\n        val firstParam = Set(\n          \"open\",\n          \"fopen\",\n          \"creat\",\n          \"access\",\n          \"chmod\",\n          \"readlink\",\n          \"chown\",\n          \"lchown\",\n          \"stat\",\n          \"lstat\",\n          \"unlink\",\n          \"rmdir\",\n          \"mkdir\",\n          \"mknod\",\n          \"mkfifo\",\n          \"chdir\",\n          \"link\",\n          \"rename\"\n        )\n        val secondParam = Set(\n          \"openat\",\n          \"fstatat\",\n          \"fchmodat\",\n          \"readlinkat\",\n          \"unlinkat\",\n          \"mkdirat\",\n          \"mknodat\",\n          \"mkfifoat\",\n          \"faccessat\",\n          \"link\",\n          \"rename\",\n          \"linkat\",\n          \"renameat\"\n        )\n        val fourthParam = Set(\"linkat\", \"renameat\")\n\n        val anyParam = firstParam ++ secondParam ++ fourthParam\n\n        def fileCalls(calls: Traversal[Call]) =\n          calls.nameExact(anyParam.toSeq: _*)\n\n        def fileArgs(c: Call) = {\n          val res = Traversal.newBuilder[Expression]\n          // note some functions are in multiple setts because they take multiple paths\n          if (firstParam.contains(c.name)) {\n            res.addOne(c.argument(1))\n          }\n          if (secondParam.contains(c.name)) {\n            res.addOne(c.argument(2))\n          }\n          if (fourthParam.contains(c.name)) {\n            res.addOne(c.argument(4))\n          }\n          res.result().whereNot(_.isLiteral)\n        }\n\n        fileCalls(cpg.call)\n          .filter(call => {\n            val otherCalls = fileCalls(call.method.ast.isCall).filter(_ != call)\n            val argsForOtherCalls =\n              otherCalls.flatMap(c => fileArgs(c)).code.toSet\n\n            fileArgs(call).code.exists(arg => argsForOtherCalls.contains(arg))\n          })","tags":["race-condition","default"],"language":"c","codeExamples":{"positive":[],"negative":[]}},{"name":"strlen-truncation","author":"@fabsx00","title":"Truncation in assignment involving `strlen` call","description":"\nThe return value of `strlen` is stored in a variable that is known\nto be of type `int` as opposed to `size_t`. `int` is only 32 bit\nwide on many 64 bit platforms, and thus, this may result in a\ntruncation.\n","score":2.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method\n          .name(\"(?i)strlen\")\n          .callIn\n          .inAssignment\n          .target\n          .evalType(\"(g?)int\")","tags":["integers","default"],"language":"c","codeExamples":{"positive":["\n\nint vulnerable(char *str) {\n  int len;\n  len = strlen(str);\n}\n\n"],"negative":["\n\nint non_vulnerable(char *str) {\n  size_t len;\n  len = strlen(str);\n}\n\n"]}}]