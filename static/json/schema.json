{"schemas":[{"name":"MetaData","description":"\nThe Meta Data Layer contains information about CPG creation. In particular,\nit indicates which language frontend generated the CPG and which overlays\nhave been applied. The layer consists of a single node - the Meta Data node -\nand language frontends MUST create this node. Overlay creators MUST edit\nthis node to indicate that a layer has been successfully applied in all\ncases where applying the layer more than once is prohibitive.\n","providedByFrontend":true},{"name":"FileSystem","description":"\nCPGs are created from sets of files and the File System Layer describes the layout of\nthese files, that is, it provides information about source files\nand shared objects for source-based and machine-code-based frontends\nrespectively. The purpose of including this information in the CPG\nis to allow nodes of the graph to be mapped back to file system locations.\n","providedByFrontend":false},{"name":"Namespace","description":"\nMany programming languages allow code to be structured into namespaces. The Namespace\nLayer makes these namespaces explicit and associates program constructs with the\nnamespaces they are defined in.\n","providedByFrontend":false},{"name":"Method","description":"\nThe Method Layer contains declarations of methods, functions, and procedures.\nInput parameters and output parameters (including return parameters) are\nrepresented, however, method contents is not present in this layer.\n","providedByFrontend":true},{"name":"Type","description":"\nThe Type Layer contains information about type declarations, relations between\ntypes, and type instantiation and usage. In its current form, it allows moedling of\nparametrized types, type hierarchies and aliases.\n","providedByFrontend":true},{"name":"Ast","description":"\nThe Abstract Syntax Tree (AST) Layer provides syntax trees for all compilation units.\nAll nodes of the tree inherit from the same base class (`AST_NODE`) and are connected\nto their child nodes via outgoing `AST` edges.\n\nSyntax trees are typed, that is, when possible, types for all expressions are stored\nin the tree. Moreover, common control structure types are defined in the specification,\nmaking it possible to translate trees into corresponding control flow graphs if only\nthese common control structure types are used, possibly by desugaring on the side of\nthe language frontend. For cases where this is not an option,\nthe AST specification provides means of storing language-dependent information in the\nAST that can be interpreted by language-dependent control flow construction passes.\n\nThis layer MUST be created by the frontend.\n\n","providedByFrontend":true},{"name":"CallGraph","description":"\nThis overlay represents call relations between methods.\n","providedByFrontend":false},{"name":"Cfg","description":"\n","providedByFrontend":false},{"name":"Dominators","description":"\n","providedByFrontend":false},{"name":"Pdg","description":"\n","providedByFrontend":false},{"name":"Comment","description":"\n","providedByFrontend":true},{"name":"Finding","description":"\n\n","providedByFrontend":false},{"name":"Shortcuts","description":"\nShortcut edges calculated by the backend.\nThese edges should NOT be created by the language frontend.\n","providedByFrontend":false},{"name":"TagsAndLocation","description":"\n\n","providedByFrontend":false},{"name":"Base","description":"\n","providedByFrontend":true}],"nodes":[{"name":"META_DATA","comment":"This node contains the CPG meta data. Exactly one node of this type\nMUST exist per CPG. The `HASH` property MAY contain a hash value calculated\nover the source files this CPG was generated from. The `VERSION` MUST be\nset to the version of the specification (\"1.1\"). The language field indicates\nwhich language frontend was used to generate the CPG and the list property\n`OVERLAYS` specifies which overlays have been applied to the CPG.","extends":[],"allProperties":["HASH","LANGUAGE","OVERLAYS","VERSION"],"cardinalities":["zeroOrOne","one","list","one"],"inheritedProperties":[],"properties":["HASH","LANGUAGE","OVERLAYS","VERSION"],"schema":"MetaData","schemaIndex":2,"isAbstract":false,"containedNodes":[]},{"name":"FILE","comment":"File nodes represent source files or a shared objects from which the CPG\nwas generated. File nodes serve as indices, that is, they allow looking up all\nelements of the code by file.\n\nFor each file, the graph MUST contain exactly one File node.\nAs file nodes are root nodes of abstract syntax tress, they are AstNodes and\ntheir order field is set to 0. This is because they have no sibling nodes,\nnot because they are the first node of the AST.\n\nEach CPG MUST contain a special file node with name set to\n`<unknown>`. This node is a placeholder used in cases where a file cannot be\ndetermined at compile time. As an example, consider external library functions.\nAs their code is not available on CPG construction, the file name is unknown.\n\nFile nodes MUST NOT be created by the language frontend. Instead, the language\nfrontend is assumed to fill out the `FILENAME` field wherever possible,\nallowing File nodes to be created automatically upon first loading the CPG.","extends":["AST_NODE"],"allProperties":["CODE","COLUMN_NUMBER","HASH","LINE_NUMBER","NAME","ORDER"],"cardinalities":["one","zeroOrOne","zeroOrOne","zeroOrOne","one","one"],"inheritedProperties":[{"baseType":"AST_NODE","name":"CODE"},{"baseType":"AST_NODE","name":"COLUMN_NUMBER"},{"baseType":"AST_NODE","name":"LINE_NUMBER"},{"baseType":"AST_NODE","name":"ORDER"}],"properties":["HASH","NAME"],"schema":"FileSystem","schemaIndex":3,"isAbstract":false,"containedNodes":[]},{"name":"NAMESPACE","comment":"This node represents a namespace. Similar to FILE nodes, NAMESPACE nodes\nserve as indices that allow all definitions inside a namespace to be\nobtained by following outgoing edges from a NAMESPACE node.\n                    |\nNAMESPACE nodes MUST NOT be created by language frontends. Instead,\nthey are generated from NAMESPACE_BLOCK nodes automatically upon\nfirst loading of the CPG.","extends":["AST_NODE"],"allProperties":["CODE","COLUMN_NUMBER","LINE_NUMBER","NAME","ORDER"],"cardinalities":["one","zeroOrOne","zeroOrOne","one","one"],"inheritedProperties":[{"baseType":"AST_NODE","name":"CODE"},{"baseType":"AST_NODE","name":"COLUMN_NUMBER"},{"baseType":"AST_NODE","name":"LINE_NUMBER"},{"baseType":"AST_NODE","name":"ORDER"}],"properties":["NAME"],"schema":"Namespace","schemaIndex":4,"isAbstract":false,"containedNodes":[]},{"name":"NAMESPACE_BLOCK","comment":"A reference to a namespace.\nWe borrow the concept of a \"namespace block\" from C++, that is, a namespace block\nis a block of code that has been placed in the same namespace by a programmer.\nThis block may be introduced via a `package` statement in Java or\na `namespace{ }` statement in C++.\n\nThe `FULL_NAME` field contains the namespace name in a human-readable format.\nThe name should be given in dot-separated form where a dot indicates\nthe the right hand side is a sub namespace of the left hand side, e.g.,\n`foo.bar` denotes the namespace `bar` contained in the namespace `foo`.\n\nThe `NAME` field contains the name of the namespace without the names of\nits parent namespaces, e.g., for the namespace `foo.woo.bar`, the `NAME`\nfield is `bar`.","extends":["AST_NODE"],"allProperties":["CODE","COLUMN_NUMBER","FILENAME","FULL_NAME","LINE_NUMBER","NAME","ORDER"],"cardinalities":["one","zeroOrOne","one","one","zeroOrOne","one","one"],"inheritedProperties":[{"baseType":"AST_NODE","name":"CODE"},{"baseType":"AST_NODE","name":"COLUMN_NUMBER"},{"baseType":"AST_NODE","name":"LINE_NUMBER"},{"baseType":"AST_NODE","name":"ORDER"}],"properties":["FILENAME","FULL_NAME","NAME"],"schema":"Namespace","schemaIndex":4,"isAbstract":false,"containedNodes":[]},{"name":"METHOD","comment":"Programming languages offer many closely-related concepts for describing blocks\nof code that can be executed with input parameters and return output parameters,\npossibly causing side effects. In the CPG specification, we refer to all of these\nconcepts (procedures, functions, methods, etc.) as methods. A single METHOD node\nmust exist for each method found in the source program.\n\nThe `FULL_NAME` field specifies the method's fully-qualified name, including\ninformation about the namespace it is contained in if applicable, the name field\nis the function's short name. The field `IS_EXTERNAL` indicates whether it was\npossible to identify a method body for the method. This is true for methods that\nare defined in the source program, and false for methods that are dynamically\nlinked to the program, that is, methods that exist in an external dependency.\n\nLine and column number information is specified in the optional fields\n`LINE_NUMBER`, `COLUMN_NUMBER`, `LINE_NUMBER_END`, and `COLUMN_NUMBER_END` and\nthe name of the source file is specified in `FILENAME`. An optional hash value\nMAY be calculated over the function contents and included in the `HASH` field.\n\nFinally, the fully qualified name of the program constructs that the method\nis immediately contained in is stored in the `AST_PARENT_FULL_NAME` field\nand its type is indicated in the `AST_PARENT_TYPE` field to be one of\n`METHOD`, `TYPE_DECL` or `NAMESPACE_BLOCK`.","extends":["DECLARATION","CFG_NODE","AST_NODE"],"allProperties":["AST_PARENT_FULL_NAME","AST_PARENT_TYPE","CODE","COLUMN_NUMBER","COLUMN_NUMBER_END","FILENAME","FULL_NAME","HASH","IS_EXTERNAL","LINE_NUMBER","LINE_NUMBER_END","NAME","ORDER","SIGNATURE"],"cardinalities":["one","one","one","zeroOrOne","zeroOrOne","one","one","zeroOrOne","one","zeroOrOne","zeroOrOne","one","one","one"],"inheritedProperties":[{"baseType":"DECLARATION","name":"NAME"},{"baseType":"AST_NODE","name":"COLUMN_NUMBER"},{"baseType":"AST_NODE","name":"ORDER"},{"baseType":"AST_NODE","name":"CODE"},{"baseType":"AST_NODE","name":"LINE_NUMBER"}],"properties":["AST_PARENT_FULL_NAME","AST_PARENT_TYPE","COLUMN_NUMBER_END","FILENAME","FULL_NAME","HASH","IS_EXTERNAL","LINE_NUMBER_END","SIGNATURE"],"schema":"Method","schemaIndex":5,"isAbstract":false,"containedNodes":[]},{"name":"METHOD_PARAMETER_IN","comment":"This node represents a formal input parameter. The field `NAME` contains its\nname, while the field `TYPE_FULL_NAME` contains the fully qualified type name.","extends":["DECLARATION","CFG_NODE","AST_NODE"],"allProperties":["CODE","COLUMN_NUMBER","EVALUATION_STRATEGY","LINE_NUMBER","NAME","ORDER","TYPE_FULL_NAME"],"cardinalities":["one","zeroOrOne","one","zeroOrOne","one","one","one"],"inheritedProperties":[{"baseType":"DECLARATION","name":"NAME"},{"baseType":"AST_NODE","name":"COLUMN_NUMBER"},{"baseType":"AST_NODE","name":"ORDER"},{"baseType":"AST_NODE","name":"CODE"},{"baseType":"AST_NODE","name":"LINE_NUMBER"}],"properties":["EVALUATION_STRATEGY","TYPE_FULL_NAME"],"schema":"Method","schemaIndex":5,"isAbstract":false,"containedNodes":[]},{"name":"METHOD_PARAMETER_OUT","comment":"This node represents a formal output parameter. Corresponding output parameters\nfor input parameters MUST NOT be created by the frontend as they are automatically\ncreated upon first loading the CPG.","extends":["DECLARATION","CFG_NODE","AST_NODE"],"allProperties":["CODE","COLUMN_NUMBER","EVALUATION_STRATEGY","LINE_NUMBER","NAME","ORDER","TYPE_FULL_NAME"],"cardinalities":["one","zeroOrOne","one","zeroOrOne","one","one","one"],"inheritedProperties":[{"baseType":"DECLARATION","name":"NAME"},{"baseType":"AST_NODE","name":"COLUMN_NUMBER"},{"baseType":"AST_NODE","name":"ORDER"},{"baseType":"AST_NODE","name":"CODE"},{"baseType":"AST_NODE","name":"LINE_NUMBER"}],"properties":["EVALUATION_STRATEGY","TYPE_FULL_NAME"],"schema":"Method","schemaIndex":5,"isAbstract":false,"containedNodes":[]},{"name":"METHOD_RETURN","comment":"This node represents an (unnamed) formal method return parameter. It carries its\nfully qualified type name in `TYPE_FULL_NAME`. The `CODE` field MAY be set freely,\ne.g., to the constant `RET`, however, subsequent layer creators MUST NOT depend\non this value.","extends":["CFG_NODE"],"allProperties":["CODE","COLUMN_NUMBER","EVALUATION_STRATEGY","LINE_NUMBER","ORDER","TYPE_FULL_NAME"],"cardinalities":["one","zeroOrOne","one","zeroOrOne","one","one"],"inheritedProperties":[{"baseType":"CFG_NODE","name":"CODE"},{"baseType":"CFG_NODE","name":"COLUMN_NUMBER"},{"baseType":"CFG_NODE","name":"LINE_NUMBER"},{"baseType":"CFG_NODE","name":"ORDER"}],"properties":["EVALUATION_STRATEGY","TYPE_FULL_NAME"],"schema":"Method","schemaIndex":5,"isAbstract":false,"containedNodes":[]},{"name":"MEMBER","comment":"This node represents a type member of a class, struct or union, e.g., for the\n type declaration `class Foo{ int i ; }`, it represents the declaration of the\n variable `i`.","extends":["DECLARATION","AST_NODE"],"allProperties":["CODE","COLUMN_NUMBER","LINE_NUMBER","NAME","ORDER","TYPE_FULL_NAME"],"cardinalities":["one","zeroOrOne","zeroOrOne","one","one","one"],"inheritedProperties":[{"baseType":"DECLARATION","name":"NAME"},{"baseType":"AST_NODE","name":"COLUMN_NUMBER"},{"baseType":"AST_NODE","name":"ORDER"},{"baseType":"AST_NODE","name":"CODE"},{"baseType":"AST_NODE","name":"LINE_NUMBER"}],"properties":["TYPE_FULL_NAME"],"schema":"Type","schemaIndex":6,"isAbstract":false,"containedNodes":[]},{"name":"TYPE","comment":"This node represents a type instance, that is, a concrete instantiation\nof a type declaration.","extends":[],"allProperties":["FULL_NAME","NAME","TYPE_DECL_FULL_NAME"],"cardinalities":["one","one","one"],"inheritedProperties":[],"properties":["FULL_NAME","NAME","TYPE_DECL_FULL_NAME"],"schema":"Type","schemaIndex":6,"isAbstract":false,"containedNodes":[]},{"name":"TYPE_ARGUMENT","comment":"An (actual) type argument as used to instantiate a parametrized type, in the\nsame way an (actual) arguments provides concrete values for a parameter\nat method call sites. As it true for arguments, the method is not expected\nto  interpret the type argument. It MUST however store its code in the\n`CODE` field.","extends":["AST_NODE"],"allProperties":["CODE","COLUMN_NUMBER","LINE_NUMBER","ORDER"],"cardinalities":["one","zeroOrOne","zeroOrOne","one"],"inheritedProperties":[{"baseType":"AST_NODE","name":"CODE"},{"baseType":"AST_NODE","name":"COLUMN_NUMBER"},{"baseType":"AST_NODE","name":"LINE_NUMBER"},{"baseType":"AST_NODE","name":"ORDER"}],"properties":[],"schema":"Type","schemaIndex":6,"isAbstract":false,"containedNodes":[]},{"name":"TYPE_DECL","comment":"This node represents a type declaration as for example given by a class-, struct-,\nor union declaration. In contrast to a `TYPE` node, this node does not represent a\nconcrete instantiation of a type, e.g., for the parametrized type `List[T]`, it represents\n`List[T]`, but not `List[Integer]` where `Integer` is a concrete type.\n\nThe language frontend MUST create type declarations for all types declared in the\nsource program and MAY provide type declarations for types that are not declared\nbut referenced by the source program. If a declaration is present in the source\nprogram, the field `IS_EXTERNAL` is set to `false`. Otherwise, it is set to `true`.\n\nThe `FULL_NAME` field specifies the type's fully-qualified name, including\ninformation about the namespace it is contained in if applicable, the name field\nis the type's short name. Line and column number information is specified in the\noptional fields `LINE_NUMBER`, `COLUMN_NUMBER`, `LINE_NUMBER_END`, and\n`COLUMN_NUMBER_END` and the name of the source file is specified in `FILENAME`.\n\nBase types can be specified via the `INHERITS_FROM_TYPE_FULL_NAME` list, where\neach entry contains the fully-qualified name of a base type. If the type is\nknown to be an alias of another type (as for example introduced via the C\n`typedef` statement), the name of the alias is stored in `ALIAS_TYPE_FULL_NAME`.\n\nFinally, the fully qualified name of the program constructs that the type declaration\nis immediately contained in is stored in the `AST_PARENT_FULL_NAME` field\nand its type is indicated in the `AST_PARENT_TYPE` field to be one of\n`METHOD`, `TYPE_DECL` or `NAMESPACE_BLOCK`.","extends":["AST_NODE"],"allProperties":["ALIAS_TYPE_FULL_NAME","AST_PARENT_FULL_NAME","AST_PARENT_TYPE","CODE","COLUMN_NUMBER","FILENAME","FULL_NAME","INHERITS_FROM_TYPE_FULL_NAME","IS_EXTERNAL","LINE_NUMBER","NAME","ORDER"],"cardinalities":["zeroOrOne","one","one","one","zeroOrOne","one","one","list","one","zeroOrOne","one","one"],"inheritedProperties":[{"baseType":"AST_NODE","name":"CODE"},{"baseType":"AST_NODE","name":"COLUMN_NUMBER"},{"baseType":"AST_NODE","name":"LINE_NUMBER"},{"baseType":"AST_NODE","name":"ORDER"}],"properties":["ALIAS_TYPE_FULL_NAME","AST_PARENT_FULL_NAME","AST_PARENT_TYPE","FILENAME","FULL_NAME","INHERITS_FROM_TYPE_FULL_NAME","IS_EXTERNAL","NAME"],"schema":"Type","schemaIndex":6,"isAbstract":false,"containedNodes":[]},{"name":"TYPE_PARAMETER","comment":"This node represents a formal type parameter, that is, the type parameter\nas given in a type-parametrized method or type declaration. Examples for\nlanguages that support type parameters are Java (via Generics) and C++\n(via templates). Apart from the standard fields of AST nodes, the type\nparameter carries only a `NAME` field that holds the parameters name.","extends":["AST_NODE"],"allProperties":["CODE","COLUMN_NUMBER","LINE_NUMBER","NAME","ORDER"],"cardinalities":["one","zeroOrOne","zeroOrOne","one","one"],"inheritedProperties":[{"baseType":"AST_NODE","name":"CODE"},{"baseType":"AST_NODE","name":"COLUMN_NUMBER"},{"baseType":"AST_NODE","name":"LINE_NUMBER"},{"baseType":"AST_NODE","name":"ORDER"}],"properties":["NAME"],"schema":"Type","schemaIndex":6,"isAbstract":false,"containedNodes":[]},{"name":"AST_NODE","comment":"This is the base type for all nodes of the abstract syntax tree (AST). An AST\nnode has a `CODE` and an `ORDER` field. The `CODE` field contains the\ncode (verbatim) represented by the AST node. The `ORDER` field contains the\nnodes position among its siblings, encoded as an integer where the left most\nsibling has the position `0`.\n\nAST nodes contain optional `LINE_NUMBER` and `COLUMN_NUMBER` fields. For\nsource-based frontends, these fields contain the start line number and\nstart column number of the code represented by the node.\nFor machine-code-based and bytecode-based frontends, `LINE_NUMBER` contains\nthe address at which the code starts while `COLUMN_NUMBER` is undefined.","extends":[],"allProperties":["CODE","COLUMN_NUMBER","LINE_NUMBER","ORDER"],"cardinalities":["one","zeroOrOne","zeroOrOne","one"],"inheritedProperties":[],"properties":["CODE","COLUMN_NUMBER","LINE_NUMBER","ORDER"],"schema":"Ast","schemaIndex":7,"isAbstract":true,"containedNodes":[]},{"name":"BLOCK","comment":"This node represents a compound statement. Compound statements are used in many languages to allow\ngrouping a sequence of statements. For example, in C and Java, compound statements\nare statements enclosed by curly braces. Function/Method bodies are compound\nstatements. We do not use the term \"compound statement\" because \"statement\" would\nimply that the block does not yield a value upon evaluation, that is, that it is\nnot an expression. This is true in languages such as C and Java, but not for languages\nsuch as Scala where the value of the block is given by that of the last expression it\ncontains. In fact, the Scala grammar uses the term \"BlockExpr\" (short for\n\"block expression\") to describe what in the CPG we call \"Block\".","extends":["EXPRESSION"],"allProperties":["ARGUMENT_INDEX","CODE","COLUMN_NUMBER","LINE_NUMBER","ORDER","PARAMETER_NAME","TYPE_FULL_NAME"],"cardinalities":["one","one","zeroOrOne","zeroOrOne","one","zeroOrOne","one"],"inheritedProperties":[{"baseType":"EXPRESSION","name":"PARAMETER_NAME"},{"baseType":"EXPRESSION","name":"COLUMN_NUMBER"},{"baseType":"EXPRESSION","name":"ARGUMENT_INDEX"},{"baseType":"EXPRESSION","name":"ORDER"},{"baseType":"EXPRESSION","name":"CODE"},{"baseType":"EXPRESSION","name":"LINE_NUMBER"}],"properties":["TYPE_FULL_NAME"],"schema":"Ast","schemaIndex":7,"isAbstract":false,"containedNodes":[]},{"name":"CALL","comment":"A (function/method/procedure) call. The `METHOD_FULL_NAME` property is the name of the\ninvoked method (the callee) while the `TYPE_FULL_NAME` is its return type, and\ntherefore, the return type of the call when viewing it as an expression. For\nlanguages like Javascript, it is common that we may know the (short-) name\nof the invoked method, but we do not know at compile time which method\nwill actually be invoked, e.g., because it depends on a dynamic import.\nIn this case, we leave `METHOD_FULL_NAME` blank but at least fill out `NAME`,\nwhich contains the method's (short-) name and `SIGNATURE`, which contains\nany information we may have about the types of arguments and return value.","extends":["CALL_REPR","EXPRESSION"],"allProperties":["ARGUMENT_INDEX","CODE","COLUMN_NUMBER","DISPATCH_TYPE","LINE_NUMBER","METHOD_FULL_NAME","NAME","ORDER","PARAMETER_NAME","SIGNATURE","TYPE_FULL_NAME"],"cardinalities":["one","one","zeroOrOne","one","zeroOrOne","one","one","one","zeroOrOne","one","one"],"inheritedProperties":[{"baseType":"CALL_REPR","name":"NAME"},{"baseType":"EXPRESSION","name":"PARAMETER_NAME"},{"baseType":"CALL_REPR","name":"SIGNATURE"},{"baseType":"EXPRESSION","name":"COLUMN_NUMBER"},{"baseType":"EXPRESSION","name":"ARGUMENT_INDEX"},{"baseType":"EXPRESSION","name":"ORDER"},{"baseType":"EXPRESSION","name":"CODE"},{"baseType":"EXPRESSION","name":"LINE_NUMBER"}],"properties":["DISPATCH_TYPE","METHOD_FULL_NAME","TYPE_FULL_NAME"],"schema":"Ast","schemaIndex":7,"isAbstract":false,"containedNodes":[]},{"name":"CALL_REPR","comment":"This is the base class of `CALL` that language implementers may safely ignore.","extends":["CFG_NODE"],"allProperties":["CODE","COLUMN_NUMBER","LINE_NUMBER","NAME","ORDER","SIGNATURE"],"cardinalities":["one","zeroOrOne","zeroOrOne","one","one","one"],"inheritedProperties":[{"baseType":"CFG_NODE","name":"CODE"},{"baseType":"CFG_NODE","name":"COLUMN_NUMBER"},{"baseType":"CFG_NODE","name":"LINE_NUMBER"},{"baseType":"CFG_NODE","name":"ORDER"}],"properties":["NAME","SIGNATURE"],"schema":"Ast","schemaIndex":7,"isAbstract":true,"containedNodes":[]},{"name":"CONTROL_STRUCTURE","comment":"This node represents a control structure as introduced by control structure\nstatements as well as conditional and unconditional jumps. Its type is stored in the\n`CONTROL_STRUCTURE_TYPE` field to be one of several pre-defined types. These types\n are used in the construction of the control flow layer, making it possible to\n generate the control flow layer from the abstract syntax tree layer automatically.\n\nIn addition to the `CONTROL_STRUCTURE_TYPE` field, the `PARSER_TYPE_NAME` field\nMAY be used by frontends to store the name of the control structure as emitted by\nthe parser or disassembler, however, the value of this field is not relevant\nfor construction of the control flow layer.","extends":["EXPRESSION"],"allProperties":["ARGUMENT_INDEX","CODE","COLUMN_NUMBER","CONTROL_STRUCTURE_TYPE","LINE_NUMBER","ORDER","PARAMETER_NAME","PARSER_TYPE_NAME"],"cardinalities":["one","one","zeroOrOne","one","zeroOrOne","one","zeroOrOne","one"],"inheritedProperties":[{"baseType":"EXPRESSION","name":"PARAMETER_NAME"},{"baseType":"EXPRESSION","name":"COLUMN_NUMBER"},{"baseType":"EXPRESSION","name":"ARGUMENT_INDEX"},{"baseType":"EXPRESSION","name":"ORDER"},{"baseType":"EXPRESSION","name":"CODE"},{"baseType":"EXPRESSION","name":"LINE_NUMBER"}],"properties":["CONTROL_STRUCTURE_TYPE","PARSER_TYPE_NAME"],"schema":"Ast","schemaIndex":7,"isAbstract":false,"containedNodes":[]},{"name":"EXPRESSION","comment":"`EXPRESSION` is the base class for all nodes that represent code pieces\nthat can be evaluated.\n\n Expression may be arguments in method calls. For method calls that do\n not involved named parameters, the `ARGUMENT_INDEX` field indicates at\n which position in the argument list the expression occurs, e.g., an\n `ARGUMENT_INDEX` of 1 indicates that the expression is the first argument\n in a method call. For calls that employ named parameters, `ARGUMENT_INDEX`\n is set to -1 and the `NAME` fields holds the name of the parameter.","extends":["CFG_NODE","AST_NODE"],"allProperties":["ARGUMENT_INDEX","CODE","COLUMN_NUMBER","LINE_NUMBER","ORDER","PARAMETER_NAME"],"cardinalities":["one","one","zeroOrOne","zeroOrOne","one","zeroOrOne"],"inheritedProperties":[{"baseType":"AST_NODE","name":"CODE"},{"baseType":"AST_NODE","name":"COLUMN_NUMBER"},{"baseType":"AST_NODE","name":"LINE_NUMBER"},{"baseType":"AST_NODE","name":"ORDER"}],"properties":["ARGUMENT_INDEX","PARAMETER_NAME"],"schema":"Ast","schemaIndex":7,"isAbstract":true,"containedNodes":[]},{"name":"FIELD_IDENTIFIER","comment":"This node represents the field accessed in a field access, e.g., in\n`a.b`, it represents `b`. The field name as it occurs in the code is\nstored in the `CODE` field. This may mean that the `CODE` field holds\nan expression. The `CANONICAL_NAME` field MAY contain the same value is\nthe `CODE` field but SHOULD contain the normalized name that results\nfrom evaluating `CODE` as an expression if such an evaluation is\npossible for the language frontend. The objective is to store an identifier\nin `CANONICAL_NAME` that is the same for two nodes iff they refer to the\nsame field, regardless of whether they use the same expression to reference\nit.","extends":["EXPRESSION"],"allProperties":["ARGUMENT_INDEX","CANONICAL_NAME","CODE","COLUMN_NUMBER","LINE_NUMBER","ORDER","PARAMETER_NAME"],"cardinalities":["one","one","one","zeroOrOne","zeroOrOne","one","zeroOrOne"],"inheritedProperties":[{"baseType":"EXPRESSION","name":"PARAMETER_NAME"},{"baseType":"EXPRESSION","name":"COLUMN_NUMBER"},{"baseType":"EXPRESSION","name":"ARGUMENT_INDEX"},{"baseType":"EXPRESSION","name":"ORDER"},{"baseType":"EXPRESSION","name":"CODE"},{"baseType":"EXPRESSION","name":"LINE_NUMBER"}],"properties":["CANONICAL_NAME"],"schema":"Ast","schemaIndex":7,"isAbstract":false,"containedNodes":[]},{"name":"IDENTIFIER","comment":"This node represents an identifier as used when referring to a variable by name.\nIt holds the identifier's name in the `NAME` field and its fully-qualified type\nname in `TYPE_FULL_NAME`.","extends":["EXPRESSION"],"allProperties":["ARGUMENT_INDEX","CODE","COLUMN_NUMBER","LINE_NUMBER","NAME","ORDER","PARAMETER_NAME","TYPE_FULL_NAME"],"cardinalities":["one","one","zeroOrOne","zeroOrOne","one","one","zeroOrOne","one"],"inheritedProperties":[{"baseType":"EXPRESSION","name":"PARAMETER_NAME"},{"baseType":"EXPRESSION","name":"COLUMN_NUMBER"},{"baseType":"EXPRESSION","name":"ARGUMENT_INDEX"},{"baseType":"EXPRESSION","name":"ORDER"},{"baseType":"EXPRESSION","name":"CODE"},{"baseType":"EXPRESSION","name":"LINE_NUMBER"}],"properties":["NAME","TYPE_FULL_NAME"],"schema":"Ast","schemaIndex":7,"isAbstract":false,"containedNodes":[]},{"name":"JUMP_TARGET","comment":"A jump target is any location in the code that has been specifically marked\nas the target of a jump, e.g., via a label. The `NAME` field holds the name of\nthe label while the `PARSER_TYPE_NAME` field holds the name of language construct\nthat this jump target is created from, e.g., \"Label\".","extends":["CFG_NODE","AST_NODE"],"allProperties":["ARGUMENT_INDEX","CODE","COLUMN_NUMBER","LINE_NUMBER","NAME","ORDER","PARSER_TYPE_NAME"],"cardinalities":["one","one","zeroOrOne","zeroOrOne","one","one","one"],"inheritedProperties":[{"baseType":"AST_NODE","name":"CODE"},{"baseType":"AST_NODE","name":"COLUMN_NUMBER"},{"baseType":"AST_NODE","name":"LINE_NUMBER"},{"baseType":"AST_NODE","name":"ORDER"}],"properties":["ARGUMENT_INDEX","NAME","PARSER_TYPE_NAME"],"schema":"Ast","schemaIndex":7,"isAbstract":false,"containedNodes":[]},{"name":"LITERAL","comment":"This node represents a literal such as an integer or string constant. Literals\nare symbols included in the code in verbatim form and which are immutable.\nThe `TYPE_FULL_NAME` field stores the literal's fully-qualified type name,\ne.g., `java.lang.Integer`.","extends":["EXPRESSION"],"allProperties":["ARGUMENT_INDEX","CODE","COLUMN_NUMBER","LINE_NUMBER","ORDER","PARAMETER_NAME","TYPE_FULL_NAME"],"cardinalities":["one","one","zeroOrOne","zeroOrOne","one","zeroOrOne","one"],"inheritedProperties":[{"baseType":"EXPRESSION","name":"PARAMETER_NAME"},{"baseType":"EXPRESSION","name":"COLUMN_NUMBER"},{"baseType":"EXPRESSION","name":"ARGUMENT_INDEX"},{"baseType":"EXPRESSION","name":"ORDER"},{"baseType":"EXPRESSION","name":"CODE"},{"baseType":"EXPRESSION","name":"LINE_NUMBER"}],"properties":["TYPE_FULL_NAME"],"schema":"Ast","schemaIndex":7,"isAbstract":false,"containedNodes":[]},{"name":"LOCAL","comment":"This node represents a local variable. Its fully qualified type name is stored\nin the `TYPE_FULL_NAME` field and its name in the `NAME` field. The `CODE` field\ncontains the entire local variable declaration without initialization, e.g., for\n`int x = 10;`, it contains `int x`.","extends":["DECLARATION","AST_NODE"],"allProperties":["CODE","COLUMN_NUMBER","LINE_NUMBER","NAME","ORDER","TYPE_FULL_NAME"],"cardinalities":["one","zeroOrOne","zeroOrOne","one","one","one"],"inheritedProperties":[{"baseType":"DECLARATION","name":"NAME"},{"baseType":"AST_NODE","name":"COLUMN_NUMBER"},{"baseType":"AST_NODE","name":"ORDER"},{"baseType":"AST_NODE","name":"CODE"},{"baseType":"AST_NODE","name":"LINE_NUMBER"}],"properties":["TYPE_FULL_NAME"],"schema":"Ast","schemaIndex":7,"isAbstract":false,"containedNodes":[]},{"name":"METHOD_REF","comment":"This node represents a reference to a method/function/procedure as it\nappears when a method is passed as an argument in a call. The `METHOD_FULL_NAME`\nfield holds the fully-qualified name of the referenced method and the\n`TYPE_FULL_NAME` holds its fully-qualified type name.","extends":["EXPRESSION"],"allProperties":["ARGUMENT_INDEX","CODE","COLUMN_NUMBER","LINE_NUMBER","METHOD_FULL_NAME","ORDER","PARAMETER_NAME","TYPE_FULL_NAME"],"cardinalities":["one","one","zeroOrOne","zeroOrOne","one","one","zeroOrOne","one"],"inheritedProperties":[{"baseType":"EXPRESSION","name":"PARAMETER_NAME"},{"baseType":"EXPRESSION","name":"COLUMN_NUMBER"},{"baseType":"EXPRESSION","name":"ARGUMENT_INDEX"},{"baseType":"EXPRESSION","name":"ORDER"},{"baseType":"EXPRESSION","name":"CODE"},{"baseType":"EXPRESSION","name":"LINE_NUMBER"}],"properties":["METHOD_FULL_NAME","TYPE_FULL_NAME"],"schema":"Ast","schemaIndex":7,"isAbstract":false,"containedNodes":[]},{"name":"MODIFIER","comment":"This field represents a (language-dependent) modifier such as `static`, `private`\nor `public`. Unlike most other AST nodes, it is NOT an expression, that is, it\ncannot be evaluated and cannot be passed as an argument in function calls.","extends":["AST_NODE"],"allProperties":["CODE","COLUMN_NUMBER","LINE_NUMBER","MODIFIER_TYPE","ORDER"],"cardinalities":["one","zeroOrOne","zeroOrOne","one","one"],"inheritedProperties":[{"baseType":"AST_NODE","name":"CODE"},{"baseType":"AST_NODE","name":"COLUMN_NUMBER"},{"baseType":"AST_NODE","name":"LINE_NUMBER"},{"baseType":"AST_NODE","name":"ORDER"}],"properties":["MODIFIER_TYPE"],"schema":"Ast","schemaIndex":7,"isAbstract":false,"containedNodes":[]},{"name":"RETURN","comment":"This node represents a return instruction, e.g., `return x`. Note that it does\nNOT represent a formal return parameter as formal return parameters are\nrepresented via `METHOD_RETURN` nodes.","extends":["EXPRESSION"],"allProperties":["ARGUMENT_INDEX","CODE","COLUMN_NUMBER","LINE_NUMBER","ORDER","PARAMETER_NAME"],"cardinalities":["one","one","zeroOrOne","zeroOrOne","one","zeroOrOne"],"inheritedProperties":[{"baseType":"EXPRESSION","name":"PARAMETER_NAME"},{"baseType":"EXPRESSION","name":"COLUMN_NUMBER"},{"baseType":"EXPRESSION","name":"ARGUMENT_INDEX"},{"baseType":"EXPRESSION","name":"ORDER"},{"baseType":"EXPRESSION","name":"CODE"},{"baseType":"EXPRESSION","name":"LINE_NUMBER"}],"properties":[],"schema":"Ast","schemaIndex":7,"isAbstract":false,"containedNodes":[]},{"name":"TYPE_REF","comment":"Reference to a type/class","extends":["EXPRESSION"],"allProperties":["ARGUMENT_INDEX","CODE","COLUMN_NUMBER","LINE_NUMBER","ORDER","PARAMETER_NAME","TYPE_FULL_NAME"],"cardinalities":["one","one","zeroOrOne","zeroOrOne","one","zeroOrOne","one"],"inheritedProperties":[{"baseType":"EXPRESSION","name":"PARAMETER_NAME"},{"baseType":"EXPRESSION","name":"COLUMN_NUMBER"},{"baseType":"EXPRESSION","name":"ARGUMENT_INDEX"},{"baseType":"EXPRESSION","name":"ORDER"},{"baseType":"EXPRESSION","name":"CODE"},{"baseType":"EXPRESSION","name":"LINE_NUMBER"}],"properties":["TYPE_FULL_NAME"],"schema":"Ast","schemaIndex":7,"isAbstract":false,"containedNodes":[]},{"name":"UNKNOWN","comment":"Any AST node that the frontend would like to include in the AST but for\nwhich no suitable AST node is specified in the CPG specification may be\nincluded using a node of type `UNKNOWN`.","extends":["EXPRESSION"],"allProperties":["ARGUMENT_INDEX","CODE","COLUMN_NUMBER","CONTAINED_REF","LINE_NUMBER","ORDER","PARAMETER_NAME","PARSER_TYPE_NAME","TYPE_FULL_NAME"],"cardinalities":["one","one","zeroOrOne","one","zeroOrOne","one","zeroOrOne","one","one"],"inheritedProperties":[{"baseType":"EXPRESSION","name":"PARAMETER_NAME"},{"baseType":"EXPRESSION","name":"COLUMN_NUMBER"},{"baseType":"EXPRESSION","name":"ARGUMENT_INDEX"},{"baseType":"EXPRESSION","name":"ORDER"},{"baseType":"EXPRESSION","name":"CODE"},{"baseType":"EXPRESSION","name":"LINE_NUMBER"}],"properties":["CONTAINED_REF","PARSER_TYPE_NAME","TYPE_FULL_NAME"],"schema":"Ast","schemaIndex":7,"isAbstract":false,"containedNodes":[]},{"name":"CFG_NODE","comment":"Any node that can occur as part of a control flow graph","extends":["AST_NODE"],"allProperties":["CODE","COLUMN_NUMBER","LINE_NUMBER","ORDER"],"cardinalities":["one","zeroOrOne","zeroOrOne","one"],"inheritedProperties":[{"baseType":"AST_NODE","name":"CODE"},{"baseType":"AST_NODE","name":"COLUMN_NUMBER"},{"baseType":"AST_NODE","name":"LINE_NUMBER"},{"baseType":"AST_NODE","name":"ORDER"}],"properties":[],"schema":"Cfg","schemaIndex":9,"isAbstract":true,"containedNodes":[]},{"name":"COMMENT","comment":"A source code comment","extends":[],"allProperties":["CODE","FILENAME","LINE_NUMBER"],"cardinalities":["one","one","zeroOrOne"],"inheritedProperties":[],"properties":["CODE","FILENAME","LINE_NUMBER"],"schema":"Comment","schemaIndex":12,"isAbstract":false,"containedNodes":[]},{"name":"FINDING","extends":[],"allProperties":[],"cardinalities":[],"inheritedProperties":[],"properties":[],"schema":"Finding","schemaIndex":15,"isAbstract":false,"containedNodes":[{"name":"evidence","type":"ABSTRACT_NODE","cardinality":"list"},{"name":"keyValuePairs","type":"KEY_VALUE_PAIR","cardinality":"list"}]},{"name":"KEY_VALUE_PAIR","extends":[],"allProperties":["KEY","VALUE"],"cardinalities":["one","one"],"inheritedProperties":[],"properties":["KEY","VALUE"],"schema":"Finding","schemaIndex":15,"isAbstract":false,"containedNodes":[]},{"name":"LOCATION","extends":[],"allProperties":["CLASS_NAME","CLASS_SHORT_NAME","FILENAME","LINE_NUMBER","METHOD_FULL_NAME","METHOD_SHORT_NAME","NODE_LABEL","PACKAGE_NAME","SYMBOL"],"cardinalities":["one","one","one","zeroOrOne","one","one","one","one","one"],"inheritedProperties":[],"properties":["CLASS_NAME","CLASS_SHORT_NAME","FILENAME","LINE_NUMBER","METHOD_FULL_NAME","METHOD_SHORT_NAME","NODE_LABEL","PACKAGE_NAME","SYMBOL"],"schema":"TagsAndLocation","schemaIndex":17,"isAbstract":false,"containedNodes":[{"name":"node","type":"ABSTRACT_NODE","cardinality":"zeroOrOne"}]},{"name":"TAG","comment":"A string tag","extends":[],"allProperties":["NAME","VALUE"],"cardinalities":["one","one"],"inheritedProperties":[],"properties":["NAME","VALUE"],"schema":"TagsAndLocation","schemaIndex":17,"isAbstract":false,"containedNodes":[]},{"name":"TAG_NODE_PAIR","extends":[],"allProperties":[],"cardinalities":[],"inheritedProperties":[],"properties":[],"schema":"TagsAndLocation","schemaIndex":17,"isAbstract":false,"containedNodes":[{"name":"node","type":"ABSTRACT_NODE","cardinality":"one"},{"name":"tag","type":"TAG","cardinality":"one"}]},{"name":"DECLARATION","extends":[],"allProperties":["NAME"],"cardinalities":["one"],"inheritedProperties":[],"properties":["NAME"],"schema":"Base","schemaIndex":2147483647,"isAbstract":true,"containedNodes":[]}],"edges":[{"name":"ALIAS_OF","comment":"This edge represents an alias relation between a type declaration and a type.\nThe language frontend MUST NOT create `ALIAS_OF` edges as they are created\nautomatically based on `ALIAS_TYPE_FULL_NAME` fields when the CPG is first loaded.","schema":"Type"},{"name":"ARGUMENT","comment":"Argument edges connect call sites (node type `CALL`) to their arguments\n(node type `EXPRESSION`) as well as `RETURN` nodes to the expressions\nthat return.","schema":"CallGraph"},{"name":"AST","comment":"This edge connects a parent node to its child in the syntax tree.","schema":"Ast"},{"name":"BINDS_TO","comment":"This edge connects type arguments to type parameters to indicate\nthat the type argument is used to instantiate the type parameter.","schema":"Type"},{"name":"CALL","comment":"This edge connects call sites, i.e., nodes with the type `CALL`, to the\nmethod node that represent the method they invoke. The frontend MAY create\n`CALL` edges but is not required to do so. Instead, of the `METHOD_FULL_NAME`\nfield of the `CALL` node is set correctly, `CALL` edges are created\nautomatically as the CPG is first loaded.","schema":"CallGraph"},{"name":"CDG","comment":"Control dependency graph","schema":"Pdg"},{"name":"CFG","comment":"Control flow edge","schema":"Cfg"},{"name":"CONDITION","comment":"The edge connects control structure nodes to the expressions that holds their conditions.","schema":"Ast"},{"name":"CONTAINS","comment":"Shortcut over multiple AST edges","schema":"Shortcuts"},{"name":"DOMINATE","comment":"Points to dominated node in DOM tree","schema":"Dominators"},{"name":"EVAL_TYPE","comment":"Link to evaluation type","schema":"Shortcuts"},{"name":"INHERITS_FROM","comment":"Inheritance relation between a type declaration and a type. This edge MUST NOT\n be created by the language frontend as it is automatically created from\n `INHERITS_FROM_TYPE_FULL_NAME` fields then the CPG is first loaded.","schema":"Type"},{"name":"PARAMETER_LINK","comment":"Links together corresponding METHOD_PARAMETER_IN and METHOD_PARAMETER_OUT nodes. Created by backend.","schema":"Shortcuts"},{"name":"POST_DOMINATE","comment":"Points to dominated node in post DOM tree","schema":"Dominators"},{"name":"REACHING_DEF","comment":"Reaching definition edge","schema":"Pdg"},{"name":"RECEIVER","comment":"Similar to `ARGUMENT` edges, `RECEIVER` edges connect call sites\nto their receiver arguments. A receiver argument is the object on\nwhich a method operates, that is, it is the expression that is\nassigned to the `this` pointer as control is transferred to the method.","schema":"CallGraph"},{"name":"REF","comment":"A reference to e.g. a LOCAL","schema":"Base"},{"name":"SOURCE_FILE","comment":"This edge connects a node to the node that represents its source file. These\nedges MUST not be created by the language frontend but are automatically\ncreated based on `FILENAME` fields.","schema":"FileSystem"},{"name":"TAGGED_BY","comment":"Edges from nodes to tags","schema":"TagsAndLocation"}],"properties":[{"name":"ALIAS_TYPE_FULL_NAME","comment":"This property holds the fully qualified name of the type that the node is\na type alias of.","schema":"Type"},{"name":"ARGUMENT_INDEX","comment":"AST-children of CALL nodes have an argument index, that is used to match\ncall-site arguments with callee parameters. Explicit parameters are numbered\nfrom 1 to N, while index 0 is reserved for implicit self / this parameter.\nCALLs without implicit parameter therefore have arguments starting with index 1.\nAST-children of BLOCK nodes may have an argument index as well; in this case,\nthe last argument index determines the return expression of a BLOCK expression.\nIf the `PARAMETER_NAME` field is set, then the `ARGUMENT_INDEX` field is\nignored. It is suggested to set it to -1.","schema":"CallGraph"},{"name":"AST_PARENT_FULL_NAME","comment":"The FULL_NAME of a the AST parent of an entity","schema":"Base"},{"name":"AST_PARENT_TYPE","comment":"The type of the AST parent. Since this is only used in some parts of the graph,\nthe list does not include all possible parents by intention.\nPossible parents: METHOD, TYPE_DECL, NAMESPACE_BLOCK.","schema":"Base"},{"name":"CANONICAL_NAME","comment":"This field holds the canonical name of a `FIELD_IDENTIFIER`. It is typically\nidentical to the CODE field, but canonicalized according to source language\nsemantics. Human readable names are preferable. `FIELD_IDENTIFIER` nodes must\nshare identical `CANONICAL_NAME` if and\nonly if they alias, e.g., in C-style unions (if the aliasing relationship is\nunknown or there are partial overlaps, then one must make a reasonable guess,\nand trade off between false negatives and false positives).","schema":"Ast"},{"name":"CLASS_NAME","schema":"TagsAndLocation"},{"name":"CLASS_SHORT_NAME","schema":"TagsAndLocation"},{"name":"CODE","comment":"The code snippet the node represents","schema":"Base"},{"name":"COLUMN_NUMBER","comment":"This optional fields provides the column number of the program construct\nrepresented by the node.","schema":"FileSystem"},{"name":"COLUMN_NUMBER_END","comment":"This optional fields provides the column number at which the program construct\nrepresented by the node ends.","schema":"FileSystem"},{"name":"CONTAINED_REF","comment":"References to other nodes. This is not a real property; it exists here for the sake of proto serialization only. valueType and cardinality are meaningless.","schema":"ProtoSerialize"},{"name":"CONTROL_STRUCTURE_TYPE","comment":"The `CONTROL_STRUCTURE_TYPE` field indicates which kind of control structure\na `CONTROL_STRUCTURE` node represents. The available types are the following:\n BREAK, CONTINUE, DO, WHILE, FOR, GOTO, IF, ELSE, TRY, and SWITCH.","schema":"Ast"},{"name":"DISPATCH_TYPE","comment":"This field holds the dispatch type of a call, which is either `STATIC_DISPATCH` or\n`DYNAMIC_DISPATCH`. For statically dispatched method calls, the call target is known\nat compile time while for dynamically dispatched calls, it can only be determined at\nruntime as it may depend on the type of an object (as is the case for virtual method\ncalls) or calculation of an offset.","schema":"CallGraph"},{"name":"EVALUATION_STRATEGY","comment":"For formal method input parameters, output parameters, and return parameters,\nthis field holds the evaluation strategy, which is one of the following:\n1) `BY_REFERENCE` indicates that the parameter is passed by reference, 2)\n`BY_VALUE` indicates that it is passed by value, that is, a copy is made,\n3) `BY_SHARING` the parameter is a pointer/reference and it is shared with\nthe caller/callee. While a copy of the pointer is made, a copy of the object\nthat it points to is not made.","schema":"CallGraph"},{"name":"FILENAME","comment":"The absolute path of the source file this node was generated from. This field\nmust be set but may be set to the value `<unknown>` to indicate that no source\nfile can be associated with the node, e.g., because the node represents an\nentity known to exist because it is referenced, but for which the file that\nis is declared in is unknown.","schema":"FileSystem"},{"name":"FULL_NAME","comment":"Full name of an element, e.g., the class name along, including its package\n(e.g. \\\"io.shiftleft.dataflowenging.layers.dataflows.DataFlowRunner.run\\\").\nIn theory, the FULL_NAME just needs to be unique and is used for linking references,\nso a consecutive integer would be valid. In practice, this should be human readable","schema":"Base"},{"name":"HASH","comment":"This property contains a hash value in the form of a string.\nHashes can be used to summarize data, e.g., to summarize the\ncontents of source files or sub graphs. Such summaries are useful\nto determine whether code has already been analyzed in incremental\nanalysis pipelines. This property is optional to allow its calculation\nto be deferred or skipped if the hash is not needed.","schema":"Base"},{"name":"INHERITS_FROM_TYPE_FULL_NAME","comment":"The static types a TYPE_DECL inherits from. This property is matched against the\nFULL_NAME of TYPE nodes and thus it is required to have at least one TYPE node\nfor each TYPE_FULL_NAME","schema":"Type"},{"name":"IS_EXTERNAL","comment":"Indicates that the construct (METHOD or TYPE_DECL) is external, that is,\nit is referenced but not defined in the code (applies both to insular\nparsing and to library functions where we have header files only)","schema":"Base"},{"name":"KEY","schema":"Finding"},{"name":"LANGUAGE","comment":"This field indicates which CPG language frontend generated the CPG.\nFrontend developers may freely choose a value that describes their frontend\nso long as it is not used by an existing frontend. Reserved values are to date:\nC, LLVM, GHIDRA, PHP.","schema":"MetaData"},{"name":"LINE_NUMBER","comment":"This optional field provides the line number of the program construct\nrepresented by the node.","schema":"FileSystem"},{"name":"LINE_NUMBER_END","comment":"This optional fields provides the line number at which the program construct\nrepresented by the node ends.","schema":"FileSystem"},{"name":"METHOD_FULL_NAME","comment":"The FULL_NAME of a method. Used to link CALL and METHOD nodes. It is required\nto have exactly one METHOD node for each METHOD_FULL_NAME","schema":"CallGraph"},{"name":"METHOD_SHORT_NAME","schema":"TagsAndLocation"},{"name":"MODIFIER_TYPE","comment":"The modifier type is a free-form string. The following are known modifier types:\n`STATIC`, `PUBLIC`, `PROTECTED`, `PRIVATE`, `ABSTRACT`, `NATIVE`, `CONSTRUCTOR`, `VIRTUAL`.","schema":"Ast"},{"name":"NAME","comment":"Name of represented object, e.g., method name (e.g. \"run\")","schema":"Base"},{"name":"NODE_LABEL","schema":"TagsAndLocation"},{"name":"ORDER","comment":"General ordering property, such that the children of each AST-node are\ntypically numbered from 1, ..., N (this is not enforced).","schema":"Base"},{"name":"OVERLAYS","comment":"The field contains the names of the overlays applied to this CPG, in order of their\napplication. Names are free-form strings, that is, this specification does not\ndictate them but rather requires tool producers and consumers to communicate them\nbetween each other.","schema":"MetaData"},{"name":"PACKAGE_NAME","schema":"TagsAndLocation"},{"name":"PARAMETER_NAME","comment":"For calls involving named parameters, the `PARAMETER_NAME` field holds the\nname of the parameter initialized by the expression. For all other calls,\nthis field is unset.","schema":"CallGraph"},{"name":"PARSER_TYPE_NAME","comment":"AST node type name emitted by parser.","schema":"Base"},{"name":"SIGNATURE","comment":"The method signature encodes the types of parameters in a string.\nThe string SHOULD be human readable and suitable for differentiating methods\nwith different parameter types sufficiently to allow for resolving of\nfunction overloading. The present specification does not enforce a strict\nformat for the signature, that is, it can be chosen by the frontend\nimplementor to fit the source language.","schema":"Method"},{"name":"SYMBOL","schema":"TagsAndLocation"},{"name":"TYPE_DECL_FULL_NAME","comment":"The static type decl of a TYPE. This property is matched against the FULL_NAME\nof TYPE_DECL nodes. It is required to have exactly one TYPE_DECL for each\ndifferent TYPE_DECL_FULL_NAME","schema":"Type"},{"name":"TYPE_FULL_NAME","comment":"This field contains the fully-qualified static type name of the program\nconstruct represented by a node. It is the name of an instantiated type, e.g.,\n`java.util.List<Integer>`, rather than `java.util.List[T]`. If the type\ncannot be determined, this field should be set to the empty string.","schema":"Type"},{"name":"VALUE","comment":"Generic node property","schema":"Base"},{"name":"VARIABLE","comment":"A variable propagated by a reaching-def edge","schema":"Pdg"},{"name":"VERSION","comment":"A version, given as a string. Used, for example, in the META_DATA node to\nindicate which version of the CPG spec this CPG conforms to","schema":"Base"}]}