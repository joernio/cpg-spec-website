{
  "schemas": [
    {
      "name": "MetaData",
      "description": "\nThe MetaData Layer is provided by the frontend and may be modified\nmodified by passes.\n",
      "providedByFrontend": true
    },
    {
      "name": "Method",
      "description": "\n Structural layer (namespace blocks, method declarations, and type declarations).\n This layer is provided by the frontend and may be modified by passes.\n",
      "providedByFrontend": true
    },
    {
      "name": "Enhancements",
      "description": "\n Enhancement nodes/edges that will automatically be derived from the cpg\n Note: these should *NOT* be written by the language frontend.\n",
      "providedByFrontend": false
    },
    {
      "name": "TypeDecl",
      "description": "\n Type layer.\n",
      "providedByFrontend": true
    },
    {
      "name": "MethodBody",
      "description": "\n",
      "providedByFrontend": true
    },
    {
      "name": "Closure",
      "description": "\n\n",
      "providedByFrontend": false
    },
    {
      "name": "Finding",
      "description": "\n\n",
      "providedByFrontend": false
    },
    {
      "name": "Base",
      "description": "\nThe Base Layer of the Code Property Graph. This is the specification relevant\nfor implementers of language frontends.\n",
      "providedByFrontend": true
    },
    {
      "name": "Comment",
      "description": "\n",
      "providedByFrontend": true
    },
    {
      "name": "TagsAndLocation",
      "description": "\n\n",
      "providedByFrontend": false
    }
  ],
  "nodes": [
    {
      "name": "META_DATA",
      "comment": "Node to save meta data about the graph on its properties.\nExactly one node of this type per graph",
      "extends": [],
      "inheritedProperties": [],
      "properties": [
        "HASH",
        "LANGUAGE",
        "OVERLAYS",
        "VERSION"
      ],
      "schema": "MetaData",
      "schemaIndex": 1,
      "isAbstract": false
    },
    {
      "name": "METHOD",
      "comment": "A method/function/procedure",
      "extends": [
        "DECLARATION",
        "CFG_NODE",
        "AST_NODE"
      ],
      "inheritedProperties": [
        {
          "baseType": "DECLARATION",
          "name": "NAME"
        },
        {
          "baseType": "CFG_NODE",
          "name": "CODE"
        },
        {
          "baseType": "CFG_NODE",
          "name": "COLUMN_NUMBER"
        },
        {
          "baseType": "CFG_NODE",
          "name": "LINE_NUMBER"
        },
        {
          "baseType": "CFG_NODE",
          "name": "ORDER"
        },
        {
          "baseType": "AST_NODE",
          "name": "ORDER"
        }
      ],
      "properties": [
        "AST_PARENT_FULL_NAME",
        "AST_PARENT_TYPE",
        "COLUMN_NUMBER_END",
        "FILENAME",
        "FULL_NAME",
        "HASH",
        "IS_EXTERNAL",
        "LINE_NUMBER_END",
        "SIGNATURE"
      ],
      "schema": "Method",
      "schemaIndex": 2,
      "isAbstract": false
    },
    {
      "name": "METHOD_PARAMETER_IN",
      "comment": "This node represents a formal parameter going towards the callee side",
      "extends": [
        "DECLARATION",
        "TRACKING_POINT",
        "AST_NODE",
        "LOCAL_LIKE"
      ],
      "inheritedProperties": [
        {
          "baseType": "DECLARATION",
          "name": "NAME"
        },
        {
          "baseType": "AST_NODE",
          "name": "ORDER"
        },
        {
          "baseType": "LOCAL_LIKE",
          "name": "NAME"
        }
      ],
      "properties": [
        "CODE",
        "COLUMN_NUMBER",
        "EVALUATION_STRATEGY",
        "LINE_NUMBER",
        "TYPE_FULL_NAME"
      ],
      "schema": "Method",
      "schemaIndex": 2,
      "isAbstract": false
    },
    {
      "name": "METHOD_RETURN",
      "comment": "A formal method return",
      "extends": [
        "CFG_NODE",
        "TRACKING_POINT"
      ],
      "inheritedProperties": [
        {
          "baseType": "CFG_NODE",
          "name": "CODE"
        },
        {
          "baseType": "CFG_NODE",
          "name": "COLUMN_NUMBER"
        },
        {
          "baseType": "CFG_NODE",
          "name": "LINE_NUMBER"
        },
        {
          "baseType": "CFG_NODE",
          "name": "ORDER"
        }
      ],
      "properties": [
        "EVALUATION_STRATEGY",
        "TYPE_FULL_NAME"
      ],
      "schema": "Method",
      "schemaIndex": 2,
      "isAbstract": false
    },
    {
      "name": "BINDING",
      "comment": "A binding of a METHOD into a TYPE_DECL",
      "extends": [],
      "inheritedProperties": [],
      "properties": [
        "IS_METHOD_NEVER_OVERRIDDEN",
        "NAME",
        "SIGNATURE"
      ],
      "schema": "Enhancements",
      "schemaIndex": 3,
      "isAbstract": false
    },
    {
      "name": "FILE",
      "comment": "Node representing a source file - the root of the AST.\nCode property graphs are created from sets of files.\nInformation about these files is stored in the graph to enable queries to map nodes\nof the graph back to the files that contain the code they represent.\nFor each file, the graph must contain exactly one File.\nAs file nodes are root nodes of abstract syntax tress, they are AstNodes and their\norder field is set to 0.\n\nEach code property graph must contain a special file node with name set to\n\"<unknown>\". This node is a placeholder used in cases where a file cannot be\ndetermined at compile time. As an example, consider the case where an external\ntype is introduced only at link time.\nConceptually file nodes serve as indices, e.g., they map all filenames to the\nlist of methods they contain.\n\nFile nodes MUST NOT be created by the language frontend. Instead, the language\nfrontend is assumed to fill out the FILENAME field wherever possible,\nallowing File nodes to be created automatically when the semantic CPG layer is created.",
      "extends": [
        "AST_NODE"
      ],
      "inheritedProperties": [
        {
          "baseType": "AST_NODE",
          "name": "ORDER"
        }
      ],
      "properties": [
        "HASH",
        "NAME"
      ],
      "schema": "Enhancements",
      "schemaIndex": 3,
      "isAbstract": false
    },
    {
      "name": "IMPLICIT_CALL",
      "comment": "An implicit call site hidden in a method indicated by METHOD_MAP policy entries",
      "extends": [
        "TRACKING_POINT",
        "CALL_REPR"
      ],
      "inheritedProperties": [
        {
          "baseType": "CALL_REPR",
          "name": "CODE"
        },
        {
          "baseType": "CALL_REPR",
          "name": "COLUMN_NUMBER"
        },
        {
          "baseType": "CALL_REPR",
          "name": "LINE_NUMBER"
        },
        {
          "baseType": "CALL_REPR",
          "name": "NAME"
        },
        {
          "baseType": "CALL_REPR",
          "name": "ORDER"
        },
        {
          "baseType": "CALL_REPR",
          "name": "SIGNATURE"
        }
      ],
      "properties": [],
      "schema": "Enhancements",
      "schemaIndex": 3,
      "isAbstract": false
    },
    {
      "name": "MEMBER",
      "comment": "Member of a class struct or union",
      "extends": [
        "DECLARATION",
        "AST_NODE"
      ],
      "inheritedProperties": [
        {
          "baseType": "DECLARATION",
          "name": "NAME"
        },
        {
          "baseType": "AST_NODE",
          "name": "ORDER"
        }
      ],
      "properties": [
        "CODE",
        "TYPE_FULL_NAME"
      ],
      "schema": "TypeDecl",
      "schemaIndex": 3,
      "isAbstract": false
    },
    {
      "name": "METHOD_PARAMETER_OUT",
      "comment": "This node represents a formal parameter going towards the caller side",
      "extends": [
        "DECLARATION",
        "TRACKING_POINT",
        "AST_NODE"
      ],
      "inheritedProperties": [
        {
          "baseType": "DECLARATION",
          "name": "NAME"
        },
        {
          "baseType": "AST_NODE",
          "name": "ORDER"
        }
      ],
      "properties": [
        "CODE",
        "COLUMN_NUMBER",
        "EVALUATION_STRATEGY",
        "LINE_NUMBER",
        "TYPE_FULL_NAME"
      ],
      "schema": "Enhancements",
      "schemaIndex": 3,
      "isAbstract": false
    },
    {
      "name": "NAMESPACE",
      "comment": "This node represents a namespace as a whole whereas the NAMESPACE_BLOCK is used for each grouping occurrence of a namespace in code. Single representing NAMESPACE node is required for easier navigation in the query language",
      "extends": [
        "AST_NODE"
      ],
      "inheritedProperties": [
        {
          "baseType": "AST_NODE",
          "name": "ORDER"
        }
      ],
      "properties": [
        "NAME"
      ],
      "schema": "Enhancements",
      "schemaIndex": 3,
      "isAbstract": false
    },
    {
      "name": "POST_EXECUTION_CALL",
      "comment": "Indicates the existence of a call executed on a return value or out parameter of a method after this method has been executed. This is used to model framework code calling functors returned from user code. The outgoing REF edge indicates on which returned entitity the call will happen.",
      "extends": [
        "TRACKING_POINT",
        "CALL_REPR"
      ],
      "inheritedProperties": [
        {
          "baseType": "CALL_REPR",
          "name": "CODE"
        },
        {
          "baseType": "CALL_REPR",
          "name": "COLUMN_NUMBER"
        },
        {
          "baseType": "CALL_REPR",
          "name": "LINE_NUMBER"
        },
        {
          "baseType": "CALL_REPR",
          "name": "NAME"
        },
        {
          "baseType": "CALL_REPR",
          "name": "ORDER"
        },
        {
          "baseType": "CALL_REPR",
          "name": "SIGNATURE"
        }
      ],
      "properties": [],
      "schema": "Enhancements",
      "schemaIndex": 3,
      "isAbstract": false
    },
    {
      "name": "TAG",
      "comment": "A string tag",
      "extends": [],
      "inheritedProperties": [],
      "properties": [
        "NAME",
        "VALUE"
      ],
      "schema": "Enhancements",
      "schemaIndex": 3,
      "isAbstract": false
    },
    {
      "name": "TYPE",
      "comment": "A type which always has to reference a type declaration and may have type\nargument children if the referred to type declaration is a template",
      "extends": [],
      "inheritedProperties": [],
      "properties": [
        "FULL_NAME",
        "NAME",
        "TYPE_DECL_FULL_NAME"
      ],
      "schema": "TypeDecl",
      "schemaIndex": 3,
      "isAbstract": false
    },
    {
      "name": "TYPE_ARGUMENT",
      "comment": "Argument for a TYPE_PARAMETER that belongs to a TYPE. It binds another\nTYPE to a TYPE_PARAMETER",
      "extends": [
        "AST_NODE"
      ],
      "inheritedProperties": [
        {
          "baseType": "AST_NODE",
          "name": "ORDER"
        }
      ],
      "properties": [],
      "schema": "TypeDecl",
      "schemaIndex": 3,
      "isAbstract": false
    },
    {
      "name": "TYPE_DECL",
      "comment": "A type declaration",
      "extends": [
        "AST_NODE"
      ],
      "inheritedProperties": [
        {
          "baseType": "AST_NODE",
          "name": "ORDER"
        }
      ],
      "properties": [
        "ALIAS_TYPE_FULL_NAME",
        "AST_PARENT_FULL_NAME",
        "AST_PARENT_TYPE",
        "FILENAME",
        "FULL_NAME",
        "INHERITS_FROM_TYPE_FULL_NAME",
        "IS_EXTERNAL",
        "NAME"
      ],
      "schema": "TypeDecl",
      "schemaIndex": 3,
      "isAbstract": false
    },
    {
      "name": "TYPE_PARAMETER",
      "comment": "Type parameter of TYPE_DECL or METHOD",
      "extends": [
        "AST_NODE"
      ],
      "inheritedProperties": [
        {
          "baseType": "AST_NODE",
          "name": "ORDER"
        }
      ],
      "properties": [
        "NAME"
      ],
      "schema": "TypeDecl",
      "schemaIndex": 3,
      "isAbstract": false
    },
    {
      "name": "BLOCK",
      "comment": "A compound statement. Compound statements are used in many languages to allow\ngrouping a sequence of statements. For example, in C and Java, compound statements\nare statements enclosed by curly braces. Function/Method bodies are compound\nstatements. We do not use the term \"compound statement\" because \"statement\" would\nimply that the block does not yield a value upon evaluation, that is, that it is\nnot an expression. This is true in languages such as C and Java, but not for languages\nsuch as Scala where the value of the block is given by that of the last expression it\ncontains. In fact, the Scala grammar uses the term \\\"BlockExpr\\\" (short for\n\\\"block expression\\\") to describe what in the CPG spec we just call \\\"Block\\\".",
      "extends": [
        "EXPRESSION"
      ],
      "inheritedProperties": [
        {
          "baseType": "EXPRESSION",
          "name": "ARGUMENT_INDEX"
        },
        {
          "baseType": "EXPRESSION",
          "name": "CODE"
        },
        {
          "baseType": "EXPRESSION",
          "name": "COLUMN_NUMBER"
        },
        {
          "baseType": "EXPRESSION",
          "name": "LINE_NUMBER"
        },
        {
          "baseType": "EXPRESSION",
          "name": "ORDER"
        }
      ],
      "properties": [
        "TYPE_FULL_NAME"
      ],
      "schema": "MethodBody",
      "schemaIndex": 4,
      "isAbstract": false
    },
    {
      "name": "CALL",
      "comment": "A (function/method) call. The `methodFullName` property is the name of the\ninvoked method (the callee) while the `typeFullName` is its return type, and\ntherefore, the return type of the call when viewing it as an expression. For\nlanguages like Javascript, it is common that we may know the (short-) name\nof the invoked method, but we do not know at compile time which method\nwill actually be invoked, e.g., because it depends on a dynamic import.\nIn this case, we leave `methodFullName` blank but at least fill out `name`,\nwhich contains the method's (short-) name and `signature`, which contains\nany information we may have about the types of arguments and return value.",
      "extends": [
        "CALL_REPR",
        "EXPRESSION"
      ],
      "inheritedProperties": [
        {
          "baseType": "CALL_REPR",
          "name": "CODE"
        },
        {
          "baseType": "CALL_REPR",
          "name": "COLUMN_NUMBER"
        },
        {
          "baseType": "CALL_REPR",
          "name": "LINE_NUMBER"
        },
        {
          "baseType": "CALL_REPR",
          "name": "NAME"
        },
        {
          "baseType": "CALL_REPR",
          "name": "ORDER"
        },
        {
          "baseType": "CALL_REPR",
          "name": "SIGNATURE"
        },
        {
          "baseType": "EXPRESSION",
          "name": "ARGUMENT_INDEX"
        },
        {
          "baseType": "EXPRESSION",
          "name": "CODE"
        },
        {
          "baseType": "EXPRESSION",
          "name": "COLUMN_NUMBER"
        },
        {
          "baseType": "EXPRESSION",
          "name": "LINE_NUMBER"
        },
        {
          "baseType": "EXPRESSION",
          "name": "ORDER"
        }
      ],
      "properties": [
        "DISPATCH_TYPE",
        "METHOD_FULL_NAME",
        "TYPE_FULL_NAME"
      ],
      "schema": "MethodBody",
      "schemaIndex": 4,
      "isAbstract": false
    },
    {
      "name": "CALL_REPR",
      "comment": "A base class for nodes that represent different types of calls",
      "extends": [
        "CFG_NODE"
      ],
      "inheritedProperties": [
        {
          "baseType": "CFG_NODE",
          "name": "CODE"
        },
        {
          "baseType": "CFG_NODE",
          "name": "COLUMN_NUMBER"
        },
        {
          "baseType": "CFG_NODE",
          "name": "LINE_NUMBER"
        },
        {
          "baseType": "CFG_NODE",
          "name": "ORDER"
        }
      ],
      "properties": [
        "NAME",
        "SIGNATURE"
      ],
      "schema": "MethodBody",
      "schemaIndex": 4,
      "isAbstract": true
    },
    {
      "name": "CLOSURE_BINDING",
      "comment": "Represents the binding of a LOCAL or METHOD_PARAMETER_IN into the closure of a method",
      "extends": [],
      "inheritedProperties": [],
      "properties": [
        "CLOSURE_BINDING_ID",
        "CLOSURE_ORIGINAL_NAME",
        "EVALUATION_STRATEGY"
      ],
      "schema": "Closure",
      "schemaIndex": 4,
      "isAbstract": false
    },
    {
      "name": "CONTROL_STRUCTURE",
      "comment": "A control structure such as if, while, or for",
      "extends": [
        "EXPRESSION"
      ],
      "inheritedProperties": [
        {
          "baseType": "EXPRESSION",
          "name": "ARGUMENT_INDEX"
        },
        {
          "baseType": "EXPRESSION",
          "name": "CODE"
        },
        {
          "baseType": "EXPRESSION",
          "name": "COLUMN_NUMBER"
        },
        {
          "baseType": "EXPRESSION",
          "name": "LINE_NUMBER"
        },
        {
          "baseType": "EXPRESSION",
          "name": "ORDER"
        }
      ],
      "properties": [
        "CONTROL_STRUCTURE_TYPE",
        "PARSER_TYPE_NAME"
      ],
      "schema": "MethodBody",
      "schemaIndex": 4,
      "isAbstract": false
    },
    {
      "name": "EXPRESSION",
      "comment": "Expression as a specialisation of tracking point",
      "extends": [
        "CFG_NODE",
        "TRACKING_POINT",
        "AST_NODE"
      ],
      "inheritedProperties": [
        {
          "baseType": "CFG_NODE",
          "name": "CODE"
        },
        {
          "baseType": "CFG_NODE",
          "name": "COLUMN_NUMBER"
        },
        {
          "baseType": "CFG_NODE",
          "name": "LINE_NUMBER"
        },
        {
          "baseType": "CFG_NODE",
          "name": "ORDER"
        },
        {
          "baseType": "AST_NODE",
          "name": "ORDER"
        }
      ],
      "properties": [
        "ARGUMENT_INDEX"
      ],
      "schema": "MethodBody",
      "schemaIndex": 4,
      "isAbstract": true
    },
    {
      "name": "FIELD_IDENTIFIER",
      "comment": "A node that represents which field is accessed in a <operator>.fieldAccess, in\ne.g. obj.field. The CODE part is used for human display and matching to MEMBER nodes.\nThe CANONICAL_NAME is used for dataflow tracking; typically both coincide.\nHowever, suppose that two fields foo and bar are a C-style union; then CODE refers\nto whatever the programmer wrote (obj.foo or obj.bar), but both share the same\nCANONICAL_NAME (e.g. GENERATED_foo_bar)",
      "extends": [
        "EXPRESSION"
      ],
      "inheritedProperties": [
        {
          "baseType": "EXPRESSION",
          "name": "ARGUMENT_INDEX"
        },
        {
          "baseType": "EXPRESSION",
          "name": "CODE"
        },
        {
          "baseType": "EXPRESSION",
          "name": "COLUMN_NUMBER"
        },
        {
          "baseType": "EXPRESSION",
          "name": "LINE_NUMBER"
        },
        {
          "baseType": "EXPRESSION",
          "name": "ORDER"
        }
      ],
      "properties": [
        "CANONICAL_NAME"
      ],
      "schema": "MethodBody",
      "schemaIndex": 4,
      "isAbstract": false
    },
    {
      "name": "IDENTIFIER",
      "comment": "An arbitrary identifier/reference",
      "extends": [
        "LOCAL_LIKE",
        "EXPRESSION"
      ],
      "inheritedProperties": [
        {
          "baseType": "LOCAL_LIKE",
          "name": "NAME"
        },
        {
          "baseType": "EXPRESSION",
          "name": "ARGUMENT_INDEX"
        },
        {
          "baseType": "EXPRESSION",
          "name": "CODE"
        },
        {
          "baseType": "EXPRESSION",
          "name": "COLUMN_NUMBER"
        },
        {
          "baseType": "EXPRESSION",
          "name": "LINE_NUMBER"
        },
        {
          "baseType": "EXPRESSION",
          "name": "ORDER"
        }
      ],
      "properties": [
        "TYPE_FULL_NAME"
      ],
      "schema": "MethodBody",
      "schemaIndex": 4,
      "isAbstract": false
    },
    {
      "name": "JUMP_TARGET",
      "comment": "A jump target made explicit in the code using a label",
      "extends": [
        "CFG_NODE",
        "AST_NODE"
      ],
      "inheritedProperties": [
        {
          "baseType": "CFG_NODE",
          "name": "CODE"
        },
        {
          "baseType": "CFG_NODE",
          "name": "COLUMN_NUMBER"
        },
        {
          "baseType": "CFG_NODE",
          "name": "LINE_NUMBER"
        },
        {
          "baseType": "CFG_NODE",
          "name": "ORDER"
        },
        {
          "baseType": "AST_NODE",
          "name": "ORDER"
        }
      ],
      "properties": [
        "ARGUMENT_INDEX",
        "NAME",
        "PARSER_TYPE_NAME"
      ],
      "schema": "MethodBody",
      "schemaIndex": 4,
      "isAbstract": false
    },
    {
      "name": "LITERAL",
      "comment": "Literal/Constant",
      "extends": [
        "EXPRESSION"
      ],
      "inheritedProperties": [
        {
          "baseType": "EXPRESSION",
          "name": "ARGUMENT_INDEX"
        },
        {
          "baseType": "EXPRESSION",
          "name": "CODE"
        },
        {
          "baseType": "EXPRESSION",
          "name": "COLUMN_NUMBER"
        },
        {
          "baseType": "EXPRESSION",
          "name": "LINE_NUMBER"
        },
        {
          "baseType": "EXPRESSION",
          "name": "ORDER"
        }
      ],
      "properties": [
        "TYPE_FULL_NAME"
      ],
      "schema": "MethodBody",
      "schemaIndex": 4,
      "isAbstract": false
    },
    {
      "name": "LOCAL",
      "comment": "A local variable",
      "extends": [
        "DECLARATION",
        "AST_NODE",
        "LOCAL_LIKE"
      ],
      "inheritedProperties": [
        {
          "baseType": "DECLARATION",
          "name": "NAME"
        },
        {
          "baseType": "AST_NODE",
          "name": "ORDER"
        },
        {
          "baseType": "LOCAL_LIKE",
          "name": "NAME"
        }
      ],
      "properties": [
        "CLOSURE_BINDING_ID",
        "CODE",
        "COLUMN_NUMBER",
        "LINE_NUMBER",
        "TYPE_FULL_NAME"
      ],
      "schema": "MethodBody",
      "schemaIndex": 4,
      "isAbstract": false
    },
    {
      "name": "METHOD_INST",
      "comment": "A method instance which always has to reference a method and may have type\nargument children if the referred to method is a template",
      "extends": [
        "AST_NODE"
      ],
      "inheritedProperties": [
        {
          "baseType": "AST_NODE",
          "name": "ORDER"
        }
      ],
      "properties": [
        "FULL_NAME",
        "METHOD_FULL_NAME",
        "NAME",
        "SIGNATURE"
      ],
      "schema": "MethodBody",
      "schemaIndex": 4,
      "isAbstract": false
    },
    {
      "name": "METHOD_REF",
      "comment": "Reference to a method instance",
      "extends": [
        "EXPRESSION"
      ],
      "inheritedProperties": [
        {
          "baseType": "EXPRESSION",
          "name": "ARGUMENT_INDEX"
        },
        {
          "baseType": "EXPRESSION",
          "name": "CODE"
        },
        {
          "baseType": "EXPRESSION",
          "name": "COLUMN_NUMBER"
        },
        {
          "baseType": "EXPRESSION",
          "name": "LINE_NUMBER"
        },
        {
          "baseType": "EXPRESSION",
          "name": "ORDER"
        }
      ],
      "properties": [
        "METHOD_FULL_NAME",
        "TYPE_FULL_NAME"
      ],
      "schema": "MethodBody",
      "schemaIndex": 4,
      "isAbstract": false
    },
    {
      "name": "RETURN",
      "comment": "A return instruction",
      "extends": [
        "EXPRESSION"
      ],
      "inheritedProperties": [
        {
          "baseType": "EXPRESSION",
          "name": "ARGUMENT_INDEX"
        },
        {
          "baseType": "EXPRESSION",
          "name": "CODE"
        },
        {
          "baseType": "EXPRESSION",
          "name": "COLUMN_NUMBER"
        },
        {
          "baseType": "EXPRESSION",
          "name": "LINE_NUMBER"
        },
        {
          "baseType": "EXPRESSION",
          "name": "ORDER"
        }
      ],
      "properties": [],
      "schema": "MethodBody",
      "schemaIndex": 4,
      "isAbstract": false
    },
    {
      "name": "TYPE_REF",
      "comment": "Reference to a type/class",
      "extends": [
        "EXPRESSION"
      ],
      "inheritedProperties": [
        {
          "baseType": "EXPRESSION",
          "name": "ARGUMENT_INDEX"
        },
        {
          "baseType": "EXPRESSION",
          "name": "CODE"
        },
        {
          "baseType": "EXPRESSION",
          "name": "COLUMN_NUMBER"
        },
        {
          "baseType": "EXPRESSION",
          "name": "LINE_NUMBER"
        },
        {
          "baseType": "EXPRESSION",
          "name": "ORDER"
        }
      ],
      "properties": [
        "TYPE_FULL_NAME"
      ],
      "schema": "MethodBody",
      "schemaIndex": 4,
      "isAbstract": false
    },
    {
      "name": "UNKNOWN",
      "comment": "A language-specific node",
      "extends": [
        "EXPRESSION"
      ],
      "inheritedProperties": [
        {
          "baseType": "EXPRESSION",
          "name": "ARGUMENT_INDEX"
        },
        {
          "baseType": "EXPRESSION",
          "name": "CODE"
        },
        {
          "baseType": "EXPRESSION",
          "name": "COLUMN_NUMBER"
        },
        {
          "baseType": "EXPRESSION",
          "name": "LINE_NUMBER"
        },
        {
          "baseType": "EXPRESSION",
          "name": "ORDER"
        }
      ],
      "properties": [
        "CONTAINED_REF",
        "PARSER_TYPE_NAME",
        "TYPE_FULL_NAME"
      ],
      "schema": "MethodBody",
      "schemaIndex": 4,
      "isAbstract": false
    },
    {
      "name": "AST_NODE",
      "comment": "Base type for all nodes are (in particular) nodes of the abstract syntax tree.\nIn a syntax tree, sibling nodes (nodes who share a parent node) are ordered.\nAs some graph databases do not guarantee the order in which siblings are returned to\nbe stable, we make the ordering explicit by storing the position of each node relative\nto its siblings in the order field. In the left most sibling, order is set to 0,\nwhile in the right-most sibling, it is set to n-1 where n is the number of siblings.",
      "extends": [],
      "inheritedProperties": [],
      "properties": [
        "ORDER"
      ],
      "schema": "Base",
      "schemaIndex": 5,
      "isAbstract": true
    },
    {
      "name": "CFG_NODE",
      "comment": "Any node that can occur as part of a control flow graph",
      "extends": [
        "AST_NODE",
        "WITHIN_METHOD"
      ],
      "inheritedProperties": [
        {
          "baseType": "AST_NODE",
          "name": "ORDER"
        }
      ],
      "properties": [
        "CODE",
        "COLUMN_NUMBER",
        "LINE_NUMBER"
      ],
      "schema": "Base",
      "schemaIndex": 5,
      "isAbstract": true
    },
    {
      "name": "DECLARATION",
      "extends": [],
      "inheritedProperties": [],
      "properties": [
        "NAME"
      ],
      "schema": "Base",
      "schemaIndex": 5,
      "isAbstract": true
    },
    {
      "name": "FINDING",
      "extends": [],
      "inheritedProperties": [],
      "properties": [],
      "schema": "Finding",
      "schemaIndex": 5,
      "isAbstract": false
    },
    {
      "name": "KEY_VALUE_PAIR",
      "extends": [],
      "inheritedProperties": [],
      "properties": [
        "KEY",
        "VALUE"
      ],
      "schema": "Finding",
      "schemaIndex": 5,
      "isAbstract": false
    },
    {
      "name": "LOCAL_LIKE",
      "comment": "Formal input parameters, locals, and identifiers",
      "extends": [],
      "inheritedProperties": [],
      "properties": [
        "NAME"
      ],
      "schema": "Base",
      "schemaIndex": 5,
      "isAbstract": true
    },
    {
      "name": "MODIFIER",
      "comment": "A modifier, e.g., static, public, private",
      "extends": [
        "AST_NODE"
      ],
      "inheritedProperties": [
        {
          "baseType": "AST_NODE",
          "name": "ORDER"
        }
      ],
      "properties": [
        "MODIFIER_TYPE"
      ],
      "schema": "Base",
      "schemaIndex": 5,
      "isAbstract": false
    },
    {
      "name": "NAMESPACE_BLOCK",
      "comment": "A reference to a namespace.\nWe borrow the concept of a \"namespace block\" from C++, that is, a namespace block\nis a block of code that has been placed in the same namespace by a programmer.\nThis block may be introduced via a `package` statement in Java or\na `namespace{ }` statement in C++.",
      "extends": [
        "AST_NODE"
      ],
      "inheritedProperties": [
        {
          "baseType": "AST_NODE",
          "name": "ORDER"
        }
      ],
      "properties": [
        "FILENAME",
        "FULL_NAME",
        "NAME"
      ],
      "schema": "Base",
      "schemaIndex": 5,
      "isAbstract": false
    },
    {
      "name": "TRACKING_POINT",
      "comment": "Any node that can occur in a data flow",
      "extends": [
        "WITHIN_METHOD"
      ],
      "inheritedProperties": [],
      "properties": [],
      "schema": "Base",
      "schemaIndex": 5,
      "isAbstract": true
    },
    {
      "name": "WITHIN_METHOD",
      "comment": "Any node that can exist in a method",
      "extends": [],
      "inheritedProperties": [],
      "properties": [],
      "schema": "Base",
      "schemaIndex": 5,
      "isAbstract": true
    },
    {
      "name": "COMMENT",
      "comment": "A source code comment",
      "extends": [],
      "inheritedProperties": [],
      "properties": [
        "CODE",
        "FILENAME",
        "LINE_NUMBER"
      ],
      "schema": "Comment",
      "schemaIndex": 6,
      "isAbstract": false
    },
    {
      "name": "LOCATION",
      "extends": [],
      "inheritedProperties": [],
      "properties": [
        "CLASS_NAME",
        "CLASS_SHORT_NAME",
        "FILENAME",
        "LINE_NUMBER",
        "METHOD_FULL_NAME",
        "METHOD_SHORT_NAME",
        "NODE_LABEL",
        "PACKAGE_NAME",
        "SYMBOL"
      ],
      "schema": "TagsAndLocation",
      "schemaIndex": 7,
      "isAbstract": false
    },
    {
      "name": "SINK",
      "extends": [],
      "inheritedProperties": [],
      "properties": [
        "SINK_TYPE"
      ],
      "schema": "TagsAndLocation",
      "schemaIndex": 7,
      "isAbstract": false
    },
    {
      "name": "SOURCE",
      "extends": [],
      "inheritedProperties": [],
      "properties": [
        "SOURCE_TYPE"
      ],
      "schema": "TagsAndLocation",
      "schemaIndex": 7,
      "isAbstract": false
    },
    {
      "name": "TAG_NODE_PAIR",
      "extends": [],
      "inheritedProperties": [],
      "properties": [],
      "schema": "TagsAndLocation",
      "schemaIndex": 7,
      "isAbstract": false
    }
  ]
}
